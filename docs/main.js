/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/fast-json-stable-stringify/index.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/CachedSource.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-sources/lib/CachedSource.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\nconst streamChunksOfSourceMap = __webpack_require__(/*! ./helpers/streamChunksOfSourceMap */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js\");\nconst streamChunksOfRawSource = __webpack_require__(/*! ./helpers/streamChunksOfRawSource */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js\");\nconst streamAndGetSourceAndMap = __webpack_require__(/*! ./helpers/streamAndGetSourceAndMap */ \"./node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js\");\n\nconst mapToBufferedMap = map => {\n\tif (typeof map !== \"object\" || !map) return map;\n\tconst bufferedMap = Object.assign({}, map);\n\tif (map.mappings) {\n\t\tbufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n\t}\n\tif (map.sourcesContent) {\n\t\tbufferedMap.sourcesContent = map.sourcesContent.map(\n\t\t\tstr => str && Buffer.from(str, \"utf-8\")\n\t\t);\n\t}\n\treturn bufferedMap;\n};\n\nconst bufferedMapToMap = bufferedMap => {\n\tif (typeof bufferedMap !== \"object\" || !bufferedMap) return bufferedMap;\n\tconst map = Object.assign({}, bufferedMap);\n\tif (bufferedMap.mappings) {\n\t\tmap.mappings = bufferedMap.mappings.toString(\"utf-8\");\n\t}\n\tif (bufferedMap.sourcesContent) {\n\t\tmap.sourcesContent = bufferedMap.sourcesContent.map(\n\t\t\tbuffer => buffer && buffer.toString(\"utf-8\")\n\t\t);\n\t}\n\treturn map;\n};\n\nclass CachedSource extends Source {\n\tconstructor(source, cachedData) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._cachedSourceType = cachedData ? cachedData.source : undefined;\n\t\tthis._cachedSource = undefined;\n\t\tthis._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n\t\tthis._cachedSize = cachedData ? cachedData.size : undefined;\n\t\tthis._cachedMaps = cachedData ? cachedData.maps : new Map();\n\t\tthis._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n\t}\n\n\tgetCachedData() {\n\t\tconst bufferedMaps = new Map();\n\t\tfor (const pair of this._cachedMaps) {\n\t\t\tlet cacheEntry = pair[1];\n\t\t\tif (cacheEntry.bufferedMap === undefined) {\n\t\t\t\tcacheEntry.bufferedMap = mapToBufferedMap(\n\t\t\t\t\tthis._getMapFromCacheEntry(cacheEntry)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbufferedMaps.set(pair[0], {\n\t\t\t\tmap: undefined,\n\t\t\t\tbufferedMap: cacheEntry.bufferedMap\n\t\t\t});\n\t\t}\n\t\t// We don't want to cache strings\n\t\t// So if we have a caches sources\n\t\t// create a buffer from it and only store\n\t\t// if it was a Buffer or string\n\t\tif (this._cachedSource) {\n\t\t\tthis.buffer();\n\t\t}\n\t\treturn {\n\t\t\tbuffer: this._cachedBuffer,\n\t\t\tsource:\n\t\t\t\tthis._cachedSourceType !== undefined\n\t\t\t\t\t? this._cachedSourceType\n\t\t\t\t\t: typeof this._cachedSource === \"string\"\n\t\t\t\t\t? true\n\t\t\t\t\t: Buffer.isBuffer(this._cachedSource)\n\t\t\t\t\t? false\n\t\t\t\t\t: undefined,\n\t\t\tsize: this._cachedSize,\n\t\t\tmaps: bufferedMaps,\n\t\t\thash: this._cachedHashUpdate\n\t\t};\n\t}\n\n\toriginalLazy() {\n\t\treturn this._source;\n\t}\n\n\toriginal() {\n\t\tif (typeof this._source === \"function\") this._source = this._source();\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) return source;\n\t\treturn (this._cachedSource = this.original().source());\n\t}\n\n\t_getMapFromCacheEntry(cacheEntry) {\n\t\tif (cacheEntry.map !== undefined) {\n\t\t\treturn cacheEntry.map;\n\t\t} else if (cacheEntry.bufferedMap !== undefined) {\n\t\t\treturn (cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap));\n\t\t}\n\t}\n\n\t_getCachedSource() {\n\t\tif (this._cachedSource !== undefined) return this._cachedSource;\n\t\tif (this._cachedBuffer && this._cachedSourceType !== undefined) {\n\t\t\treturn (this._cachedSource = this._cachedSourceType\n\t\t\t\t? this._cachedBuffer.toString(\"utf-8\")\n\t\t\t\t: this._cachedBuffer);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\t\tif (this._cachedSource !== undefined) {\n\t\t\tif (Buffer.isBuffer(this._cachedSource)) {\n\t\t\t\treturn (this._cachedBuffer = this._cachedSource);\n\t\t\t}\n\t\t\treturn (this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\"));\n\t\t}\n\t\tif (typeof this.original().buffer === \"function\") {\n\t\t\treturn (this._cachedBuffer = this.original().buffer());\n\t\t}\n\t\tconst bufferOrString = this.source();\n\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\treturn (this._cachedBuffer = bufferOrString);\n\t\t}\n\t\treturn (this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\"));\n\t}\n\n\tsize() {\n\t\tif (this._cachedSize !== undefined) return this._cachedSize;\n\t\tif (this._cachedBuffer !== undefined) {\n\t\t\treturn (this._cachedSize = this._cachedBuffer.length);\n\t\t}\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) {\n\t\t\treturn (this._cachedSize = Buffer.byteLength(source));\n\t\t}\n\t\treturn (this._cachedSize = this.original().size());\n\t}\n\n\tsourceAndMap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\t// Look for a cached map\n\t\tif (cacheEntry !== undefined) {\n\t\t\t// We have a cached map in some representation\n\t\t\tconst map = this._getMapFromCacheEntry(cacheEntry);\n\t\t\t// Either get the cached source or compute it\n\t\t\treturn { source: this.source(), map };\n\t\t}\n\t\t// Look for a cached source\n\t\tlet source = this._getCachedSource();\n\t\t// Compute the map\n\t\tlet map;\n\t\tif (source !== undefined) {\n\t\t\tmap = this.original().map(options);\n\t\t} else {\n\t\t\t// Compute the source and map together.\n\t\t\tconst sourceAndMap = this.original().sourceAndMap(options);\n\t\t\tsource = sourceAndMap.source;\n\t\t\tmap = sourceAndMap.map;\n\t\t\tthis._cachedSource = source;\n\t\t}\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn { source, map };\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tif (\n\t\t\tthis._cachedMaps.has(key) &&\n\t\t\t(this._cachedBuffer !== undefined || this._cachedSource !== undefined)\n\t\t) {\n\t\t\tconst { source, map } = this.sourceAndMap(options);\n\t\t\tif (map) {\n\t\t\t\treturn streamChunksOfSourceMap(\n\t\t\t\t\tsource,\n\t\t\t\t\tmap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn streamChunksOfRawSource(\n\t\t\t\t\tsource,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst { result, source, map } = streamAndGetSourceAndMap(\n\t\t\tthis.original(),\n\t\t\toptions,\n\t\t\tonChunk,\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\tthis._cachedSource = source;\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn result;\n\t}\n\n\tmap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn this._getMapFromCacheEntry(cacheEntry);\n\t\t}\n\t\tconst map = this.original().map(options);\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn map;\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._cachedHashUpdate !== undefined) {\n\t\t\tfor (const item of this._cachedHashUpdate) hash.update(item);\n\t\t\treturn;\n\t\t}\n\t\tconst update = [];\n\t\tlet currentString = undefined;\n\t\tconst tracker = {\n\t\t\tupdate: item => {\n\t\t\t\tif (typeof item === \"string\" && item.length < 10240) {\n\t\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\t\tcurrentString = item;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentString += item;\n\t\t\t\t\t\tif (currentString.length > 102400) {\n\t\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tupdate.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.original().updateHash(tracker);\n\t\tif (currentString !== undefined) {\n\t\t\tupdate.push(Buffer.from(currentString));\n\t\t}\n\t\tfor (const item of update) hash.update(item);\n\t\tthis._cachedHashUpdate = update;\n\t}\n}\n\nmodule.exports = CachedSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/CachedSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/CompatSource.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-sources/lib/CompatSource.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\n\nclass CompatSource extends Source {\n\tstatic from(sourceLike) {\n\t\treturn sourceLike instanceof Source\n\t\t\t? sourceLike\n\t\t\t: new CompatSource(sourceLike);\n\t}\n\n\tconstructor(sourceLike) {\n\t\tsuper();\n\t\tthis._sourceLike = sourceLike;\n\t}\n\n\tsource() {\n\t\treturn this._sourceLike.source();\n\t}\n\n\tbuffer() {\n\t\tif (typeof this._sourceLike.buffer === \"function\") {\n\t\t\treturn this._sourceLike.buffer();\n\t\t}\n\t\treturn super.buffer();\n\t}\n\n\tsize() {\n\t\tif (typeof this._sourceLike.size === \"function\") {\n\t\t\treturn this._sourceLike.size();\n\t\t}\n\t\treturn super.size();\n\t}\n\n\tmap(options) {\n\t\tif (typeof this._sourceLike.map === \"function\") {\n\t\t\treturn this._sourceLike.map(options);\n\t\t}\n\t\treturn super.map(options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (typeof this._sourceLike.sourceAndMap === \"function\") {\n\t\t\treturn this._sourceLike.sourceAndMap(options);\n\t\t}\n\t\treturn super.sourceAndMap(options);\n\t}\n\n\tupdateHash(hash) {\n\t\tif (typeof this._sourceLike.updateHash === \"function\") {\n\t\t\treturn this._sourceLike.updateHash(hash);\n\t\t}\n\t\tif (typeof this._sourceLike.map === \"function\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"A Source-like object with a 'map' method must also provide an 'updateHash' method\"\n\t\t\t);\n\t\t}\n\t\thash.update(this.buffer());\n\t}\n}\n\nmodule.exports = CompatSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/CompatSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/ConcatSource.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-sources/lib/ConcatSource.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\nconst RawSource = __webpack_require__(/*! ./RawSource */ \"./node_modules/webpack-sources/lib/RawSource.js\");\nconst streamChunks = __webpack_require__(/*! ./helpers/streamChunks */ \"./node_modules/webpack-sources/lib/helpers/streamChunks.js\");\nconst { getMap, getSourceAndMap } = __webpack_require__(/*! ./helpers/getFromStreamChunks */ \"./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js\");\n\nconst stringsAsRawSources = new WeakSet();\n\nclass ConcatSource extends Source {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._children = [];\n\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\tconst item = arguments[i];\n\t\t\tif (item instanceof ConcatSource) {\n\t\t\t\tfor (const child of item._children) {\n\t\t\t\t\tthis._children.push(child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._children.push(item);\n\t\t\t}\n\t\t}\n\t\tthis._isOptimized = arguments.length === 0;\n\t}\n\n\tgetChildren() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\treturn this._children;\n\t}\n\n\tadd(item) {\n\t\tif (item instanceof ConcatSource) {\n\t\t\tfor (const child of item._children) {\n\t\t\t\tthis._children.push(child);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._children.push(item);\n\t\t}\n\t\tthis._isOptimized = false;\n\t}\n\n\taddAllSkipOptimizing(items) {\n\t\tfor (const item of items) {\n\t\t\tthis._children.push(item);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tconst buffers = [];\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child.buffer === \"function\") {\n\t\t\t\tbuffers.push(child.buffer());\n\t\t\t} else {\n\t\t\t\tconst bufferOrString = child.source();\n\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\tbuffers.push(bufferOrString);\n\t\t\t\t} else {\n\t\t\t\t\t// This will not happen\n\t\t\t\t\tbuffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Buffer.concat(buffers);\n\t}\n\n\tsource() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet source = \"\";\n\t\tfor (const child of this._children) {\n\t\t\tsource += child.source();\n\t\t}\n\t\treturn source;\n\t}\n\n\tsize() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet size = 0;\n\t\tfor (const child of this._children) {\n\t\t\tsize += child.size();\n\t\t}\n\t\treturn size;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tif (this._children.length === 1)\n\t\t\treturn this._children[0].streamChunks(options, onChunk, onSource, onName);\n\t\tlet currentLineOffset = 0;\n\t\tlet currentColumnOffset = 0;\n\t\tlet sourceMapping = new Map();\n\t\tlet nameMapping = new Map();\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tlet code = \"\";\n\t\tlet needToCloseMapping = false;\n\t\tfor (const item of this._children) {\n\t\t\tconst sourceIndexMapping = [];\n\t\t\tconst nameIndexMapping = [];\n\t\t\tlet lastMappingLine = 0;\n\t\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\t\titem,\n\t\t\t\toptions,\n\t\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\t\t(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t) => {\n\t\t\t\t\tconst line = generatedLine + currentLineOffset;\n\t\t\t\t\tconst column =\n\t\t\t\t\t\tgeneratedLine === 1\n\t\t\t\t\t\t\t? generatedColumn + currentColumnOffset\n\t\t\t\t\t\t\t: generatedColumn;\n\t\t\t\t\tif (needToCloseMapping) {\n\t\t\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t\t}\n\t\t\t\t\tconst resultSourceIndex =\n\t\t\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\t\t\tconst resultNameIndex =\n\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: nameIndexMapping[nameIndex];\n\t\t\t\t\tlastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\t\t\t\t\tif (finalSource) {\n\t\t\t\t\t\tif (chunk !== undefined) code += chunk;\n\t\t\t\t\t\tif (resultSourceIndex >= 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (resultSourceIndex < 0) {\n\t\t\t\t\t\t\tonChunk(chunk, line, column, -1, -1, -1, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t\t},\n\t\t\t\t(i, name) => {\n\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t}\n\t\t\t\t\tnameIndexMapping[i] = globalIndex;\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (source !== undefined) code += source;\n\t\t\tif (needToCloseMapping) {\n\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1\n\t\t\t\t\t);\n\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (generatedLine > 1) {\n\t\t\t\tcurrentColumnOffset = generatedColumn;\n\t\t\t} else {\n\t\t\t\tcurrentColumnOffset += generatedColumn;\n\t\t\t}\n\t\t\tneedToCloseMapping =\n\t\t\t\tneedToCloseMapping ||\n\t\t\t\t(finalSource && lastMappingLine === generatedLine);\n\t\t\tcurrentLineOffset += generatedLine - 1;\n\t\t}\n\t\treturn {\n\t\t\tgeneratedLine: currentLineOffset + 1,\n\t\t\tgeneratedColumn: currentColumnOffset,\n\t\t\tsource: finalSource ? code : undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\thash.update(\"ConcatSource\");\n\t\tfor (const item of this._children) {\n\t\t\titem.updateHash(hash);\n\t\t}\n\t}\n\n\t_optimize() {\n\t\tconst newChildren = [];\n\t\tlet currentString = undefined;\n\t\tlet currentRawSources = undefined;\n\t\tconst addStringToRawSources = string => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = string;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(string);\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tstring\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst addSourceToRawSources = source => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = source;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(source.source());\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tsource.source()\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst mergeRawSources = () => {\n\t\t\tif (Array.isArray(currentRawSources)) {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources.join(\"\"));\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else if (typeof currentRawSources === \"string\") {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources);\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else {\n\t\t\t\tnewChildren.push(currentRawSources);\n\t\t\t}\n\t\t};\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child === \"string\") {\n\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\tcurrentString = child;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentString += child;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\taddStringToRawSources(currentString);\n\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t}\n\t\t\t\tif (stringsAsRawSources.has(child)) {\n\t\t\t\t\taddSourceToRawSources(child);\n\t\t\t\t} else {\n\t\t\t\t\tif (currentRawSources !== undefined) {\n\t\t\t\t\t\tmergeRawSources();\n\t\t\t\t\t\tcurrentRawSources = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (currentString !== undefined) {\n\t\t\taddStringToRawSources(currentString);\n\t\t}\n\t\tif (currentRawSources !== undefined) {\n\t\t\tmergeRawSources();\n\t\t}\n\t\tthis._children = newChildren;\n\t\tthis._isOptimized = true;\n\t}\n}\n\nmodule.exports = ConcatSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/ConcatSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/OriginalSource.js":
/*!************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/OriginalSource.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst { getMap, getSourceAndMap } = __webpack_require__(/*! ./helpers/getFromStreamChunks */ \"./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js\");\nconst splitIntoLines = __webpack_require__(/*! ./helpers/splitIntoLines */ \"./node_modules/webpack-sources/lib/helpers/splitIntoLines.js\");\nconst getGeneratedSourceInfo = __webpack_require__(/*! ./helpers/getGeneratedSourceInfo */ \"./node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js\");\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\nconst splitIntoPotentialTokens = __webpack_require__(/*! ./helpers/splitIntoPotentialTokens */ \"./node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js\");\n\nclass OriginalSource extends Source {\n\tconstructor(value, name) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tthis._value = isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._name = name;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\tonSource(0, this._name, this._value);\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tif (!options || options.columns !== false) {\n\t\t\t// With column info we need to read all lines and split them\n\t\t\tconst matches = splitIntoPotentialTokens(this._value);\n\t\t\tlet line = 1;\n\t\t\tlet column = 0;\n\t\t\tif (matches !== null) {\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst isEndOfLine = match.endsWith(\"\\n\");\n\t\t\t\t\tif (isEndOfLine && match.length === 1) {\n\t\t\t\t\t\tif (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst chunk = finalSource ? undefined : match;\n\t\t\t\t\t\tonChunk(chunk, line, column, 0, line, column, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (isEndOfLine) {\n\t\t\t\t\t\tline++;\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn += match.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tgeneratedLine: line,\n\t\t\t\tgeneratedColumn: column,\n\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t};\n\t\t} else if (finalSource) {\n\t\t\t// Without column info and with final source we only\n\t\t\t// need meta info to generate mapping\n\t\t\tconst result = getGeneratedSourceInfo(this._value);\n\t\t\tconst { generatedLine, generatedColumn } = result;\n\t\t\tif (generatedColumn === 0) {\n\t\t\t\tfor (let line = 1; line < generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t} else {\n\t\t\t\tfor (let line = 1; line <= generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\t// Without column info, but also without final source\n\t\t\t// we need to split source by lines\n\t\t\tlet line = 1;\n\t\t\tconst matches = splitIntoLines(this._value);\n\t\t\tlet match;\n\t\t\tfor (match of matches) {\n\t\t\t\tonChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n\t\t\t\tline++;\n\t\t\t}\n\t\t\treturn matches.length === 0 || match.endsWith(\"\\n\")\n\t\t\t\t? {\n\t\t\t\t\t\tgeneratedLine: matches.length + 1,\n\t\t\t\t\t\tgeneratedColumn: 0,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  }\n\t\t\t\t: {\n\t\t\t\t\t\tgeneratedLine: matches.length,\n\t\t\t\t\t\tgeneratedColumn: match.length,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  };\n\t\t}\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"OriginalSource\");\n\t\thash.update(this._valueAsBuffer);\n\t\thash.update(this._name || \"\");\n\t}\n}\n\nmodule.exports = OriginalSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/OriginalSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/PrefixSource.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-sources/lib/PrefixSource.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\nconst RawSource = __webpack_require__(/*! ./RawSource */ \"./node_modules/webpack-sources/lib/RawSource.js\");\nconst streamChunks = __webpack_require__(/*! ./helpers/streamChunks */ \"./node_modules/webpack-sources/lib/helpers/streamChunks.js\");\nconst { getMap, getSourceAndMap } = __webpack_require__(/*! ./helpers/getFromStreamChunks */ \"./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js\");\n\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nclass PrefixSource extends Source {\n\tconstructor(prefix, source) {\n\t\tsuper();\n\t\tthis._source =\n\t\t\ttypeof source === \"string\" || Buffer.isBuffer(source)\n\t\t\t\t? new RawSource(source, true)\n\t\t\t\t: source;\n\t\tthis._prefix = prefix;\n\t}\n\n\tgetPrefix() {\n\t\treturn this._prefix;\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst node = this._source.source();\n\t\tconst prefix = this._prefix;\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t}\n\n\t// TODO efficient buffer() implementation\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst prefix = this._prefix;\n\t\tconst prefixOffset = prefix.length;\n\t\tconst linesOnly = !!(options && options.columns === false);\n\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\tthis._source,\n\t\t\toptions,\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tif (generatedColumn !== 0) {\n\t\t\t\t\t// In the middle of the line, we just adject the column\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t} else if (chunk !== undefined) {\n\t\t\t\t\t// At the start of the line, when we have source content\n\t\t\t\t\t// add the prefix as generated mapping\n\t\t\t\t\t// (in lines only mode we just add it to the original mapping\n\t\t\t\t\t// for performance reasons)\n\t\t\t\t\tif (linesOnly || sourceIndex < 0) {\n\t\t\t\t\t\tchunk = prefix + chunk;\n\t\t\t\t\t} else if (prefixOffset > 0) {\n\t\t\t\t\t\tonChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t\t}\n\t\t\t\t} else if (!linesOnly) {\n\t\t\t\t\t// Without source content, we only need to adject the column info\n\t\t\t\t\t// expect in lines only mode where prefix is added to original mapping\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t}\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t);\n\t\t\t},\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\treturn {\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n\t\t\tsource:\n\t\t\t\tsource !== undefined\n\t\t\t\t\t? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix)\n\t\t\t\t\t: undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(\"PrefixSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._prefix);\n\t}\n}\n\nmodule.exports = PrefixSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/PrefixSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/RawSource.js":
/*!*******************************************************!*\
  !*** ./node_modules/webpack-sources/lib/RawSource.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst streamChunksOfRawSource = __webpack_require__(/*! ./helpers/streamChunksOfRawSource */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js\");\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\n\nclass RawSource extends Source {\n\tconstructor(value, convertToString = false) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tif (!isBuffer && typeof value !== \"string\") {\n\t\t\tthrow new TypeError(\"argument 'value' must be either string of Buffer\");\n\t\t}\n\t\tthis._valueIsBuffer = !convertToString && isBuffer;\n\t\tthis._value = convertToString && isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._valueAsString = isBuffer ? undefined : value;\n\t}\n\n\tisBuffer() {\n\t\treturn this._valueIsBuffer;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = Buffer.from(this._valueAsBuffer, \"utf-8\");\n\t\t}\n\t\tif (this._valueAsString === undefined) {\n\t\t\tthis._valueAsString =\n\t\t\t\ttypeof this._value === \"string\"\n\t\t\t\t\t? this._value\n\t\t\t\t\t: this._value.toString(\"utf-8\");\n\t\t}\n\t\treturn streamChunksOfRawSource(\n\t\t\tthis._valueAsString,\n\t\t\tonChunk,\n\t\t\tonSource,\n\t\t\tonName,\n\t\t\t!!(options && options.finalSource)\n\t\t);\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"RawSource\");\n\t\thash.update(this._valueAsBuffer);\n\t}\n}\n\nmodule.exports = RawSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/RawSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/ReplaceSource.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-sources/lib/ReplaceSource.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst { getMap, getSourceAndMap } = __webpack_require__(/*! ./helpers/getFromStreamChunks */ \"./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js\");\nconst streamChunks = __webpack_require__(/*! ./helpers/streamChunks */ \"./node_modules/webpack-sources/lib/helpers/streamChunks.js\");\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\nconst splitIntoLines = __webpack_require__(/*! ./helpers/splitIntoLines */ \"./node_modules/webpack-sources/lib/helpers/splitIntoLines.js\");\n\n// since v8 7.0, Array.prototype.sort is stable\nconst hasStableSort =\n\ttypeof process === \"object\" &&\n\tprocess.versions &&\n\ttypeof process.versions.v8 === \"string\" &&\n\t!/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n\tconstructor(start, end, content, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.name = name;\n\t\tif (!hasStableSort) {\n\t\t\tthis.index = -1;\n\t\t}\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis._replacements = [];\n\t\tthis._isSorted = true;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tgetReplacements() {\n\t\tthis._sortReplacements();\n\t\treturn this._replacements;\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(start, end, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" +\n\t\t\t\t\ttypeof newValue +\n\t\t\t\t\t\": \" +\n\t\t\t\t\tnewValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tsource() {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.source();\n\t\t}\n\t\tlet current = this._source.source();\n\t\tlet pos = 0;\n\t\tconst result = [];\n\n\t\tthis._sortReplacements();\n\t\tfor (const replacement of this._replacements) {\n\t\t\tconst start = Math.floor(replacement.start);\n\t\t\tconst end = Math.floor(replacement.end + 1);\n\t\t\tif (pos < start) {\n\t\t\t\tconst offset = start - pos;\n\t\t\t\tresult.push(current.slice(0, offset));\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = start;\n\t\t\t}\n\t\t\tresult.push(replacement.content);\n\t\t\tif (pos < end) {\n\t\t\t\tconst offset = end - pos;\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = end;\n\t\t\t}\n\t\t}\n\t\tresult.push(current);\n\t\treturn result.join(\"\");\n\t}\n\n\tmap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.map(options);\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.sourceAndMap(options);\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tif (this._isSorted) return;\n\t\tif (hasStableSort) {\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._replacements.forEach((repl, i) => (repl.index = i));\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn a.index - b.index;\n\t\t\t});\n\t\t}\n\t\tthis._isSorted = true;\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tthis._sortReplacements();\n\t\tconst repls = this._replacements;\n\t\tlet pos = 0;\n\t\tlet i = 0;\n\t\tlet replacmentEnd = -1;\n\t\tlet nextReplacement =\n\t\t\ti < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\t\tlet generatedLineOffset = 0;\n\t\tlet generatedColumnOffset = 0;\n\t\tlet generatedColumnOffsetLine = 0;\n\t\tconst sourceContents = [];\n\t\tconst nameMapping = new Map();\n\t\tconst nameIndexMapping = [];\n\t\tconst checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n\t\t\tlet content =\n\t\t\t\tsourceIndex < sourceContents.length\n\t\t\t\t\t? sourceContents[sourceIndex]\n\t\t\t\t\t: undefined;\n\t\t\tif (content === undefined) return false;\n\t\t\tif (typeof content === \"string\") {\n\t\t\t\tcontent = splitIntoLines(content);\n\t\t\t\tsourceContents[sourceIndex] = content;\n\t\t\t}\n\t\t\tconst contentLine = line <= content.length ? content[line - 1] : null;\n\t\t\tif (contentLine === null) return false;\n\t\t\treturn (\n\t\t\t\tcontentLine.slice(column, column + expectedChunk.length) ===\n\t\t\t\texpectedChunk\n\t\t\t);\n\t\t};\n\t\tlet { generatedLine, generatedColumn } = streamChunks(\n\t\t\tthis._source,\n\t\t\tObject.assign({}, options, { finalSource: false }),\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tlet chunkPos = 0;\n\t\t\t\tlet endPos = pos + chunk.length;\n\n\t\t\t\t// Skip over when it has been replaced\n\t\t\t\tif (replacmentEnd > pos) {\n\t\t\t\t\t// Skip over the whole chunk\n\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgeneratedColumnOffset = -chunk.length;\n\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\tchunkPos = replacmentEnd - pos;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tchunk.slice(0, chunkPos)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\toriginalColumn += chunkPos;\n\t\t\t\t\t}\n\t\t\t\t\tpos += chunkPos;\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\tgeneratedColumnOffset -= chunkPos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgeneratedColumnOffset = -chunkPos;\n\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t}\n\t\t\t\t\tgeneratedColumn += chunkPos;\n\t\t\t\t}\n\n\t\t\t\t// Is a replacement in the chunk?\n\t\t\t\tif (nextReplacement < endPos) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (nextReplacement > pos) {\n\t\t\t\t\t\t\t// Emit chunk until replacement\n\t\t\t\t\t\t\tconst offset = nextReplacement - pos;\n\t\t\t\t\t\t\tconst chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t\t: nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos = nextReplacement;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunkSlice\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += chunkSlice.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Insert replacement content splitted into chunks by lines\n\t\t\t\t\t\tconst regexp = /[^\\n]+\\n?|\\n/g;\n\t\t\t\t\t\tconst { content, name } = repls[i];\n\t\t\t\t\t\tlet match = regexp.exec(content);\n\t\t\t\t\t\tlet replacementNameIndex = nameIndex;\n\t\t\t\t\t\tif (sourceIndex >= 0 && name) {\n\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treplacementNameIndex = globalIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (match !== null) {\n\t\t\t\t\t\t\tconst contentLine = match[0];\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tcontentLine,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\treplacementNameIndex\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Only the first chunk has name assigned\n\t\t\t\t\t\t\treplacementNameIndex = -1;\n\n\t\t\t\t\t\t\tmatch = regexp.exec(content);\n\t\t\t\t\t\t\tif (match === null && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedLineOffset++;\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove replaced content by settings this variable\n\t\t\t\t\t\treplacmentEnd = Math.max(\n\t\t\t\t\t\t\treplacmentEnd,\n\t\t\t\t\t\t\tMath.floor(repls[i].end + 1)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Move to next replacment\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tnextReplacement =\n\t\t\t\t\t\t\ti < repls.length\n\t\t\t\t\t\t\t\t? Math.floor(repls[i].start)\n\t\t\t\t\t\t\t\t: MAX_SOURCE_POSITION;\n\n\t\t\t\t\t\t// Skip over when it has been replaced\n\t\t\t\t\t\tconst offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\t\t\t\t\t\tif (offset > 0) {\n\t\t\t\t\t\t\t// Skip over whole chunk\n\t\t\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length - chunkPos;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = chunkPos - chunk.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunk.slice(chunkPos, chunkPos + offset)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += offset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos += offset;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset -= offset;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -offset;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (nextReplacement < endPos);\n\t\t\t\t}\n\n\t\t\t\t// Emit remaining chunk\n\t\t\t\tif (chunkPos < chunk.length) {\n\t\t\t\t\tconst chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex < 0 ? -1 : nameIndexMapping[nameIndex]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tpos = endPos;\n\t\t\t},\n\t\t\t(sourceIndex, source, sourceContent) => {\n\t\t\t\twhile (sourceContents.length < sourceIndex)\n\t\t\t\t\tsourceContents.push(undefined);\n\t\t\t\tsourceContents[sourceIndex] = sourceContent;\n\t\t\t\tonSource(sourceIndex, source, sourceContent);\n\t\t\t},\n\t\t\t(nameIndex, name) => {\n\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t}\n\t\t\t\tnameIndexMapping[nameIndex] = globalIndex;\n\t\t\t}\n\t\t);\n\n\t\t// Handle remaining replacements\n\t\tlet remainer = \"\";\n\t\tfor (; i < repls.length; i++) {\n\t\t\tremainer += repls[i].content;\n\t\t}\n\n\t\t// Insert remaining replacements content splitted into chunks by lines\n\t\tlet line = generatedLine + generatedLineOffset;\n\t\tconst regexp = /[^\\n]+\\n?|\\n/g;\n\t\tlet match = regexp.exec(remainer);\n\t\twhile (match !== null) {\n\t\t\tconst contentLine = match[0];\n\t\t\tonChunk(\n\t\t\t\tcontentLine,\n\t\t\t\tline,\n\t\t\t\tgeneratedColumn +\n\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t);\n\n\t\t\tmatch = regexp.exec(remainer);\n\t\t\tif (match === null && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t} else {\n\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgeneratedLineOffset++;\n\t\t\t\tline++;\n\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgeneratedLine: line,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn +\n\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._sortReplacements();\n\t\thash.update(\"ReplaceSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._name || \"\");\n\t\tfor (const repl of this._replacements) {\n\t\t\thash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n\t\t}\n\t}\n}\n\nmodule.exports = ReplaceSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/ReplaceSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/SizeOnlySource.js":
/*!************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/SizeOnlySource.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\n\nclass SizeOnlySource extends Source {\n\tconstructor(size) {\n\t\tsuper();\n\t\tthis._size = size;\n\t}\n\n\t_error() {\n\t\treturn new Error(\n\t\t\t\"Content and Map of this Source is not available (only size() is supported)\"\n\t\t);\n\t}\n\n\tsize() {\n\t\treturn this._size;\n\t}\n\n\tsource() {\n\t\tthrow this._error();\n\t}\n\n\tbuffer() {\n\t\tthrow this._error();\n\t}\n\n\tmap(options) {\n\t\tthrow this._error();\n\t}\n\n\tupdateHash() {\n\t\tthrow this._error();\n\t}\n}\n\nmodule.exports = SizeOnlySource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/SizeOnlySource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/Source.js":
/*!****************************************************!*\
  !*** ./node_modules/webpack-sources/lib/Source.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nclass Source {\n\tsource() {\n\t\tthrow new Error(\"Abstract\");\n\t}\n\n\tbuffer() {\n\t\tconst source = this.source();\n\t\tif (Buffer.isBuffer(source)) return source;\n\t\treturn Buffer.from(source, \"utf-8\");\n\t}\n\n\tsize() {\n\t\treturn this.buffer().length;\n\t}\n\n\tmap(options) {\n\t\treturn null;\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn {\n\t\t\tsource: this.source(),\n\t\t\tmap: this.map(options)\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tthrow new Error(\"Abstract\");\n\t}\n}\n\nmodule.exports = Source;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/Source.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/SourceMapSource.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/SourceMapSource.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Source = __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\");\nconst streamChunksOfSourceMap = __webpack_require__(/*! ./helpers/streamChunksOfSourceMap */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js\");\nconst streamChunksOfCombinedSourceMap = __webpack_require__(/*! ./helpers/streamChunksOfCombinedSourceMap */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js\");\nconst { getMap, getSourceAndMap } = __webpack_require__(/*! ./helpers/getFromStreamChunks */ \"./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js\");\n\nclass SourceMapSource extends Source {\n\tconstructor(\n\t\tvalue,\n\t\tname,\n\t\tsourceMap,\n\t\toriginalSource,\n\t\tinnerSourceMap,\n\t\tremoveOriginalSource\n\t) {\n\t\tsuper();\n\t\tconst valueIsBuffer = Buffer.isBuffer(value);\n\t\tthis._valueAsString = valueIsBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = valueIsBuffer ? value : undefined;\n\n\t\tthis._name = name;\n\n\t\tthis._hasSourceMap = !!sourceMap;\n\t\tconst sourceMapIsBuffer = Buffer.isBuffer(sourceMap);\n\t\tconst sourceMapIsString = typeof sourceMap === \"string\";\n\t\tthis._sourceMapAsObject =\n\t\t\tsourceMapIsBuffer || sourceMapIsString ? undefined : sourceMap;\n\t\tthis._sourceMapAsString = sourceMapIsString ? sourceMap : undefined;\n\t\tthis._sourceMapAsBuffer = sourceMapIsBuffer ? sourceMap : undefined;\n\n\t\tthis._hasOriginalSource = !!originalSource;\n\t\tconst originalSourceIsBuffer = Buffer.isBuffer(originalSource);\n\t\tthis._originalSourceAsString = originalSourceIsBuffer\n\t\t\t? undefined\n\t\t\t: originalSource;\n\t\tthis._originalSourceAsBuffer = originalSourceIsBuffer\n\t\t\t? originalSource\n\t\t\t: undefined;\n\n\t\tthis._hasInnerSourceMap = !!innerSourceMap;\n\t\tconst innerSourceMapIsBuffer = Buffer.isBuffer(innerSourceMap);\n\t\tconst innerSourceMapIsString = typeof innerSourceMap === \"string\";\n\t\tthis._innerSourceMapAsObject =\n\t\t\tinnerSourceMapIsBuffer || innerSourceMapIsString\n\t\t\t\t? undefined\n\t\t\t\t: innerSourceMap;\n\t\tthis._innerSourceMapAsString = innerSourceMapIsString\n\t\t\t? innerSourceMap\n\t\t\t: undefined;\n\t\tthis._innerSourceMapAsBuffer = innerSourceMapIsBuffer\n\t\t\t? innerSourceMap\n\t\t\t: undefined;\n\n\t\tthis._removeOriginalSource = removeOriginalSource;\n\t}\n\n\t_ensureValueBuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._valueAsString, \"utf-8\");\n\t\t}\n\t}\n\n\t_ensureValueString() {\n\t\tif (this._valueAsString === undefined) {\n\t\t\tthis._valueAsString = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t}\n\n\t_ensureOriginalSourceBuffer() {\n\t\tif (this._originalSourceAsBuffer === undefined && this._hasOriginalSource) {\n\t\t\tthis._originalSourceAsBuffer = Buffer.from(\n\t\t\t\tthis._originalSourceAsString,\n\t\t\t\t\"utf-8\"\n\t\t\t);\n\t\t}\n\t}\n\n\t_ensureOriginalSourceString() {\n\t\tif (this._originalSourceAsString === undefined && this._hasOriginalSource) {\n\t\t\tthis._originalSourceAsString = this._originalSourceAsBuffer.toString(\n\t\t\t\t\"utf-8\"\n\t\t\t);\n\t\t}\n\t}\n\n\t_ensureInnerSourceMapObject() {\n\t\tif (this._innerSourceMapAsObject === undefined && this._hasInnerSourceMap) {\n\t\t\tthis._ensureInnerSourceMapString();\n\t\t\tthis._innerSourceMapAsObject = JSON.parse(this._innerSourceMapAsString);\n\t\t}\n\t}\n\n\t_ensureInnerSourceMapBuffer() {\n\t\tif (this._innerSourceMapAsBuffer === undefined && this._hasInnerSourceMap) {\n\t\t\tthis._ensureInnerSourceMapString();\n\t\t\tthis._innerSourceMapAsBuffer = Buffer.from(\n\t\t\t\tthis._innerSourceMapAsString,\n\t\t\t\t\"utf-8\"\n\t\t\t);\n\t\t}\n\t}\n\n\t_ensureInnerSourceMapString() {\n\t\tif (this._innerSourceMapAsString === undefined && this._hasInnerSourceMap) {\n\t\t\tif (this._innerSourceMapAsBuffer !== undefined) {\n\t\t\t\tthis._innerSourceMapAsString = this._innerSourceMapAsBuffer.toString(\n\t\t\t\t\t\"utf-8\"\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._innerSourceMapAsString = JSON.stringify(\n\t\t\t\t\tthis._innerSourceMapAsObject\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t_ensureSourceMapObject() {\n\t\tif (this._sourceMapAsObject === undefined) {\n\t\t\tthis._ensureSourceMapString();\n\t\t\tthis._sourceMapAsObject = JSON.parse(this._sourceMapAsString);\n\t\t}\n\t}\n\n\t_ensureSourceMapBuffer() {\n\t\tif (this._sourceMapAsBuffer === undefined) {\n\t\t\tthis._ensureSourceMapString();\n\t\t\tthis._sourceMapAsBuffer = Buffer.from(this._sourceMapAsString, \"utf-8\");\n\t\t}\n\t}\n\n\t_ensureSourceMapString() {\n\t\tif (this._sourceMapAsString === undefined) {\n\t\t\tif (this._sourceMapAsBuffer !== undefined) {\n\t\t\t\tthis._sourceMapAsString = this._sourceMapAsBuffer.toString(\"utf-8\");\n\t\t\t} else {\n\t\t\t\tthis._sourceMapAsString = JSON.stringify(this._sourceMapAsObject);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetArgsAsBuffers() {\n\t\tthis._ensureValueBuffer();\n\t\tthis._ensureSourceMapBuffer();\n\t\tthis._ensureOriginalSourceBuffer();\n\t\tthis._ensureInnerSourceMapBuffer();\n\t\treturn [\n\t\t\tthis._valueAsBuffer,\n\t\t\tthis._name,\n\t\t\tthis._sourceMapAsBuffer,\n\t\t\tthis._originalSourceAsBuffer,\n\t\t\tthis._innerSourceMapAsBuffer,\n\t\t\tthis._removeOriginalSource\n\t\t];\n\t}\n\n\tbuffer() {\n\t\tthis._ensureValueBuffer();\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tsource() {\n\t\tthis._ensureValueString();\n\t\treturn this._valueAsString;\n\t}\n\n\tmap(options) {\n\t\tif (!this._hasInnerSourceMap) {\n\t\t\tthis._ensureSourceMapObject();\n\t\t\treturn this._sourceMapAsObject;\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (!this._hasInnerSourceMap) {\n\t\t\tthis._ensureValueString();\n\t\t\tthis._ensureSourceMapObject();\n\t\t\treturn {\n\t\t\t\tsource: this._valueAsString,\n\t\t\t\tmap: this._sourceMapAsObject\n\t\t\t};\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tthis._ensureValueString();\n\t\tthis._ensureSourceMapObject();\n\t\tthis._ensureOriginalSourceString();\n\t\tif (this._hasInnerSourceMap) {\n\t\t\tthis._ensureInnerSourceMapObject();\n\t\t\treturn streamChunksOfCombinedSourceMap(\n\t\t\t\tthis._valueAsString,\n\t\t\t\tthis._sourceMapAsObject,\n\t\t\t\tthis._name,\n\t\t\t\tthis._originalSourceAsString,\n\t\t\t\tthis._innerSourceMapAsObject,\n\t\t\t\tthis._removeOriginalSource,\n\t\t\t\tonChunk,\n\t\t\t\tonSource,\n\t\t\t\tonName,\n\t\t\t\t!!(options && options.finalSource),\n\t\t\t\t!!(options && options.columns !== false)\n\t\t\t);\n\t\t} else {\n\t\t\treturn streamChunksOfSourceMap(\n\t\t\t\tthis._valueAsString,\n\t\t\t\tthis._sourceMapAsObject,\n\t\t\t\tonChunk,\n\t\t\t\tonSource,\n\t\t\t\tonName,\n\t\t\t\t!!(options && options.finalSource),\n\t\t\t\t!!(options && options.columns !== false)\n\t\t\t);\n\t\t}\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._ensureValueBuffer();\n\t\tthis._ensureSourceMapBuffer();\n\t\tthis._ensureOriginalSourceBuffer();\n\t\tthis._ensureInnerSourceMapBuffer();\n\n\t\thash.update(\"SourceMapSource\");\n\n\t\thash.update(this._valueAsBuffer);\n\n\t\thash.update(this._sourceMapAsBuffer);\n\n\t\tif (this._hasOriginalSource) {\n\t\t\thash.update(this._originalSourceAsBuffer);\n\t\t}\n\n\t\tif (this._hasInnerSourceMap) {\n\t\t\thash.update(this._innerSourceMapAsBuffer);\n\t\t}\n\n\t\thash.update(this._removeOriginalSource ? \"true\" : \"false\");\n\t}\n}\n\nmodule.exports = SourceMapSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/SourceMapSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\n\t\"\"\n);\n\nconst CONTINUATION_BIT = 0x20;\n\nconst createMappingsSerializer = options => {\n\tconst linesOnly = options && options.columns === false;\n\treturn linesOnly\n\t\t? createLinesOnlyMappingsSerializer()\n\t\t: createFullMappingsSerializer();\n};\n\nconst createFullMappingsSerializer = () => {\n\tlet currentLine = 1;\n\tlet currentColumn = 0;\n\tlet currentSourceIndex = 0;\n\tlet currentOriginalLine = 1;\n\tlet currentOriginalColumn = 0;\n\tlet currentNameIndex = 0;\n\tlet activeMapping = false;\n\tlet activeName = false;\n\tlet initial = true;\n\treturn (\n\t\tgeneratedLine,\n\t\tgeneratedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\tnameIndex\n\t) => {\n\t\tif (activeMapping && currentLine === generatedLine) {\n\t\t\t// A mapping is still active\n\t\t\tif (\n\t\t\t\tsourceIndex === currentSourceIndex &&\n\t\t\t\toriginalLine === currentOriginalLine &&\n\t\t\t\toriginalColumn === currentOriginalColumn &&\n\t\t\t\t!activeName &&\n\t\t\t\tnameIndex < 0\n\t\t\t) {\n\t\t\t\t// avoid repeating the same original mapping\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t} else {\n\t\t\t// No mapping is active\n\t\t\tif (sourceIndex < 0) {\n\t\t\t\t// avoid writing unneccessary generated mappings\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\tlet str;\n\t\tif (currentLine < generatedLine) {\n\t\t\tstr = \";\".repeat(generatedLine - currentLine);\n\t\t\tcurrentLine = generatedLine;\n\t\t\tcurrentColumn = 0;\n\t\t\tinitial = false;\n\t\t} else if (initial) {\n\t\t\tstr = \"\";\n\t\t\tinitial = false;\n\t\t} else {\n\t\t\tstr = \",\";\n\t\t}\n\n\t\tconst writeValue = value => {\n\t\t\tconst sign = (value >>> 31) & 1;\n\t\t\tconst mask = value >> 31;\n\t\t\tconst absValue = (value + mask) ^ mask;\n\t\t\tlet data = (absValue << 1) | sign;\n\t\t\tfor (;;) {\n\t\t\t\tconst sextet = data & 0x1f;\n\t\t\t\tdata >>= 5;\n\t\t\t\tif (data === 0) {\n\t\t\t\t\tstr += ALPHABET[sextet];\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tstr += ALPHABET[sextet | CONTINUATION_BIT];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\twriteValue(generatedColumn - currentColumn);\n\t\tcurrentColumn = generatedColumn;\n\t\tif (sourceIndex >= 0) {\n\t\t\tactiveMapping = true;\n\t\t\tif (sourceIndex === currentSourceIndex) {\n\t\t\t\tstr += \"A\";\n\t\t\t} else {\n\t\t\t\twriteValue(sourceIndex - currentSourceIndex);\n\t\t\t\tcurrentSourceIndex = sourceIndex;\n\t\t\t}\n\t\t\twriteValue(originalLine - currentOriginalLine);\n\t\t\tcurrentOriginalLine = originalLine;\n\t\t\tif (originalColumn === currentOriginalColumn) {\n\t\t\t\tstr += \"A\";\n\t\t\t} else {\n\t\t\t\twriteValue(originalColumn - currentOriginalColumn);\n\t\t\t\tcurrentOriginalColumn = originalColumn;\n\t\t\t}\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\twriteValue(nameIndex - currentNameIndex);\n\t\t\t\tcurrentNameIndex = nameIndex;\n\t\t\t\tactiveName = true;\n\t\t\t} else {\n\t\t\t\tactiveName = false;\n\t\t\t}\n\t\t} else {\n\t\t\tactiveMapping = false;\n\t\t}\n\t\treturn str;\n\t};\n};\n\nconst createLinesOnlyMappingsSerializer = () => {\n\tlet lastWrittenLine = 0;\n\tlet currentLine = 1;\n\tlet currentSourceIndex = 0;\n\tlet currentOriginalLine = 1;\n\treturn (\n\t\tgeneratedLine,\n\t\t_generatedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\t_originalColumn,\n\t\t_nameIndex\n\t) => {\n\t\tif (sourceIndex < 0) {\n\t\t\t// avoid writing generated mappings at all\n\t\t\treturn \"\";\n\t\t}\n\t\tif (lastWrittenLine === generatedLine) {\n\t\t\t// avoid writing multiple original mappings per line\n\t\t\treturn \"\";\n\t\t}\n\t\tlet str;\n\t\tconst writeValue = value => {\n\t\t\tconst sign = (value >>> 31) & 1;\n\t\t\tconst mask = value >> 31;\n\t\t\tconst absValue = (value + mask) ^ mask;\n\t\t\tlet data = (absValue << 1) | sign;\n\t\t\tfor (;;) {\n\t\t\t\tconst sextet = data & 0x1f;\n\t\t\t\tdata >>= 5;\n\t\t\t\tif (data === 0) {\n\t\t\t\t\tstr += ALPHABET[sextet];\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tstr += ALPHABET[sextet | CONTINUATION_BIT];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tlastWrittenLine = generatedLine;\n\t\tif (generatedLine === currentLine + 1) {\n\t\t\tcurrentLine = generatedLine;\n\t\t\tif (sourceIndex === currentSourceIndex) {\n\t\t\t\tcurrentSourceIndex = sourceIndex;\n\t\t\t\tif (originalLine === currentOriginalLine + 1) {\n\t\t\t\t\tcurrentOriginalLine = originalLine;\n\t\t\t\t\treturn \";AACA\";\n\t\t\t\t} else {\n\t\t\t\t\tstr = \";AA\";\n\t\t\t\t\twriteValue(originalLine - currentOriginalLine);\n\t\t\t\t\tcurrentOriginalLine = originalLine;\n\t\t\t\t\treturn str + \"A\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr = \";A\";\n\t\t\t\twriteValue(sourceIndex - currentSourceIndex);\n\t\t\t\tcurrentSourceIndex = sourceIndex;\n\t\t\t\twriteValue(originalLine - currentOriginalLine);\n\t\t\t\tcurrentOriginalLine = originalLine;\n\t\t\t\treturn str + \"A\";\n\t\t\t}\n\t\t} else {\n\t\t\tstr = \";\".repeat(generatedLine - currentLine);\n\t\t\tcurrentLine = generatedLine;\n\t\t\tif (sourceIndex === currentSourceIndex) {\n\t\t\t\tcurrentSourceIndex = sourceIndex;\n\t\t\t\tif (originalLine === currentOriginalLine + 1) {\n\t\t\t\t\tcurrentOriginalLine = originalLine;\n\t\t\t\t\treturn str + \"AACA\";\n\t\t\t\t} else {\n\t\t\t\t\tstr += \"AA\";\n\t\t\t\t\twriteValue(originalLine - currentOriginalLine);\n\t\t\t\t\tcurrentOriginalLine = originalLine;\n\t\t\t\t\treturn str + \"A\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr += \"A\";\n\t\t\t\twriteValue(sourceIndex - currentSourceIndex);\n\t\t\t\tcurrentSourceIndex = sourceIndex;\n\t\t\t\twriteValue(originalLine - currentOriginalLine);\n\t\t\t\tcurrentOriginalLine = originalLine;\n\t\t\t\treturn str + \"A\";\n\t\t\t}\n\t\t}\n\t};\n};\n\nmodule.exports = createMappingsSerializer;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst createMappingsSerializer = __webpack_require__(/*! ./createMappingsSerializer */ \"./node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js\");\n\nexports.getSourceAndMap = (inputSource, options) => {\n\tlet code = \"\";\n\tlet mappings = \"\";\n\tlet sources = [];\n\tlet sourcesContent = [];\n\tlet names = [];\n\tconst addMapping = createMappingsSerializer(options);\n\tconst { source } = inputSource.streamChunks(\n\t\tObject.assign({}, options, { finalSource: true }),\n\t\t(\n\t\t\tchunk,\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn,\n\t\t\tsourceIndex,\n\t\t\toriginalLine,\n\t\t\toriginalColumn,\n\t\t\tnameIndex\n\t\t) => {\n\t\t\tif (chunk !== undefined) code += chunk;\n\t\t\tmappings += addMapping(\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t);\n\t\t},\n\t\t(sourceIndex, source, sourceContent) => {\n\t\t\twhile (sources.length < sourceIndex) {\n\t\t\t\tsources.push(null);\n\t\t\t}\n\t\t\tsources[sourceIndex] = source;\n\t\t\tif (sourceContent !== undefined) {\n\t\t\t\twhile (sourcesContent.length < sourceIndex) {\n\t\t\t\t\tsourcesContent.push(null);\n\t\t\t\t}\n\t\t\t\tsourcesContent[sourceIndex] = sourceContent;\n\t\t\t}\n\t\t},\n\t\t(nameIndex, name) => {\n\t\t\twhile (names.length < nameIndex) {\n\t\t\t\tnames.push(null);\n\t\t\t}\n\t\t\tnames[nameIndex] = name;\n\t\t}\n\t);\n\treturn {\n\t\tsource: source !== undefined ? source : code,\n\t\tmap:\n\t\t\tmappings.length > 0\n\t\t\t\t? {\n\t\t\t\t\t\tversion: 3,\n\t\t\t\t\t\tfile: \"x\",\n\t\t\t\t\t\tmappings,\n\t\t\t\t\t\tsources,\n\t\t\t\t\t\tsourcesContent:\n\t\t\t\t\t\t\tsourcesContent.length > 0 ? sourcesContent : undefined,\n\t\t\t\t\t\tnames\n\t\t\t\t  }\n\t\t\t\t: null\n\t};\n};\n\nexports.getMap = (source, options) => {\n\tlet mappings = \"\";\n\tlet sources = [];\n\tlet sourcesContent = [];\n\tlet names = [];\n\tconst addMapping = createMappingsSerializer(options);\n\tsource.streamChunks(\n\t\tObject.assign({}, options, { source: false, finalSource: true }),\n\t\t(\n\t\t\tchunk,\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn,\n\t\t\tsourceIndex,\n\t\t\toriginalLine,\n\t\t\toriginalColumn,\n\t\t\tnameIndex\n\t\t) => {\n\t\t\tmappings += addMapping(\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t);\n\t\t},\n\t\t(sourceIndex, source, sourceContent) => {\n\t\t\twhile (sources.length < sourceIndex) {\n\t\t\t\tsources.push(null);\n\t\t\t}\n\t\t\tsources[sourceIndex] = source;\n\t\t\tif (sourceContent !== undefined) {\n\t\t\t\twhile (sourcesContent.length < sourceIndex) {\n\t\t\t\t\tsourcesContent.push(null);\n\t\t\t\t}\n\t\t\t\tsourcesContent[sourceIndex] = sourceContent;\n\t\t\t}\n\t\t},\n\t\t(nameIndex, name) => {\n\t\t\twhile (names.length < nameIndex) {\n\t\t\t\tnames.push(null);\n\t\t\t}\n\t\t\tnames[nameIndex] = name;\n\t\t}\n\t);\n\treturn mappings.length > 0\n\t\t? {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: \"x\",\n\t\t\t\tmappings,\n\t\t\t\tsources,\n\t\t\t\tsourcesContent: sourcesContent.length > 0 ? sourcesContent : undefined,\n\t\t\t\tnames\n\t\t  }\n\t\t: null;\n};\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js":
/*!****************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst CHAR_CODE_NEW_LINE = \"\\n\".charCodeAt(0);\n\nconst getGeneratedSourceInfo = source => {\n\tif (source === undefined) {\n\t\treturn {};\n\t}\n\tconst lastLineStart = source.lastIndexOf(\"\\n\");\n\tif (lastLineStart === -1) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: source.length,\n\t\t\tsource\n\t\t};\n\t}\n\tlet generatedLine = 2;\n\tfor (let i = 0; i < lastLineStart; i++) {\n\t\tif (source.charCodeAt(i) === CHAR_CODE_NEW_LINE) generatedLine++;\n\t}\n\treturn {\n\t\tgeneratedLine,\n\t\tgeneratedColumn: source.length - lastLineStart - 1,\n\t\tsource\n\t};\n};\n\nmodule.exports = getGeneratedSourceInfo;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/getSource.js":
/*!***************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/getSource.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst getSource = (sourceMap, index) => {\n\tif (index < 0) return null;\n\tconst { sourceRoot, sources } = sourceMap;\n\tconst source = sources[index];\n\tif (!sourceRoot) return source;\n\tif (sourceRoot.endsWith(\"/\")) return sourceRoot + source;\n\treturn sourceRoot + \"/\" + source;\n};\n\nmodule.exports = getSource;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/getSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/readMappings.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/readMappings.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst ALPHABET =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nconst CONTINUATION_BIT = 0x20;\nconst END_SEGMENT_BIT = 0x40;\nconst NEXT_LINE = END_SEGMENT_BIT | 0x01;\nconst INVALID = END_SEGMENT_BIT | 0x02;\nconst DATA_MASK = 0x1f;\n\nconst ccToValue = new Uint8Array(\"z\".charCodeAt(0) + 1);\n{\n\tccToValue.fill(INVALID);\n\tfor (let i = 0; i < ALPHABET.length; i++) {\n\t\tccToValue[ALPHABET.charCodeAt(i)] = i;\n\t}\n\tccToValue[\",\".charCodeAt(0)] = END_SEGMENT_BIT;\n\tccToValue[\";\".charCodeAt(0)] = NEXT_LINE;\n}\nconst ccMax = ccToValue.length - 1;\n\n/**\n * @param {string} mappings the mappings string\n * @param {function(number, number, number, number, number, number): void} onMapping called for each mapping\n * @returns {void}\n */\nconst readMappings = (mappings, onMapping) => {\n\t// generatedColumn, [sourceIndex, originalLine, orignalColumn, [nameIndex]]\n\tconst currentData = new Uint32Array([0, 0, 1, 0, 0]);\n\tlet currentDataPos = 0;\n\t// currentValue will include a sign bit at bit 0\n\tlet currentValue = 0;\n\tlet currentValuePos = 0;\n\tlet generatedLine = 1;\n\tlet generatedColumn = -1;\n\tfor (let i = 0; i < mappings.length; i++) {\n\t\tconst cc = mappings.charCodeAt(i);\n\t\tif (cc > ccMax) continue;\n\t\tconst value = ccToValue[cc];\n\t\tif ((value & END_SEGMENT_BIT) !== 0) {\n\t\t\t// End current segment\n\t\t\tif (currentData[0] > generatedColumn) {\n\t\t\t\tif (currentDataPos === 1) {\n\t\t\t\t\tonMapping(generatedLine, currentData[0], -1, -1, -1, -1);\n\t\t\t\t} else if (currentDataPos === 4) {\n\t\t\t\t\tonMapping(\n\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\tcurrentData[0],\n\t\t\t\t\t\tcurrentData[1],\n\t\t\t\t\t\tcurrentData[2],\n\t\t\t\t\t\tcurrentData[3],\n\t\t\t\t\t\t-1\n\t\t\t\t\t);\n\t\t\t\t} else if (currentDataPos === 5) {\n\t\t\t\t\tonMapping(\n\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\tcurrentData[0],\n\t\t\t\t\t\tcurrentData[1],\n\t\t\t\t\t\tcurrentData[2],\n\t\t\t\t\t\tcurrentData[3],\n\t\t\t\t\t\tcurrentData[4]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tgeneratedColumn = currentData[0];\n\t\t\t}\n\t\t\tcurrentDataPos = 0;\n\t\t\tif (value === NEXT_LINE) {\n\t\t\t\t// Start new line\n\t\t\t\tgeneratedLine++;\n\t\t\t\tcurrentData[0] = 0;\n\t\t\t\tgeneratedColumn = -1;\n\t\t\t}\n\t\t} else if ((value & CONTINUATION_BIT) === 0) {\n\t\t\t// last sextet\n\t\t\tcurrentValue |= value << currentValuePos;\n\t\t\tconst finalValue =\n\t\t\t\tcurrentValue & 1 ? -(currentValue >> 1) : currentValue >> 1;\n\t\t\tcurrentData[currentDataPos++] += finalValue;\n\t\t\tcurrentValuePos = 0;\n\t\t\tcurrentValue = 0;\n\t\t} else {\n\t\t\tcurrentValue |= (value & DATA_MASK) << currentValuePos;\n\t\t\tcurrentValuePos += 5;\n\t\t}\n\t}\n\t// End current segment\n\tif (currentDataPos === 1) {\n\t\tonMapping(generatedLine, currentData[0], -1, -1, -1, -1);\n\t} else if (currentDataPos === 4) {\n\t\tonMapping(\n\t\t\tgeneratedLine,\n\t\t\tcurrentData[0],\n\t\t\tcurrentData[1],\n\t\t\tcurrentData[2],\n\t\t\tcurrentData[3],\n\t\t\t-1\n\t\t);\n\t} else if (currentDataPos === 5) {\n\t\tonMapping(\n\t\t\tgeneratedLine,\n\t\t\tcurrentData[0],\n\t\t\tcurrentData[1],\n\t\t\tcurrentData[2],\n\t\t\tcurrentData[3],\n\t\t\tcurrentData[4]\n\t\t);\n\t}\n};\n\nmodule.exports = readMappings;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/readMappings.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/splitIntoLines.js":
/*!********************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/splitIntoLines.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("const splitIntoLines = str => {\n\tconst results = [];\n\tconst len = str.length;\n\tlet i = 0;\n\tfor (; i < len; ) {\n\t\tconst cc = str.charCodeAt(i);\n\t\t// 10 is \"\\n\".charCodeAt(0)\n\t\tif (cc === 10) {\n\t\t\tresults.push(\"\\n\");\n\t\t\ti++;\n\t\t} else {\n\t\t\tlet j = i + 1;\n\t\t\t// 10 is \"\\n\".charCodeAt(0)\n\t\t\twhile (j < len && str.charCodeAt(j) !== 10) j++;\n\t\t\tresults.push(str.slice(i, j + 1));\n\t\t\ti = j + 1;\n\t\t}\n\t}\n\treturn results;\n};\nmodule.exports = splitIntoLines;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/splitIntoLines.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js":
/*!******************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("// \\n = 10\n// ; = 59\n// { = 123\n// } = 125\n// <space> = 32\n// \\r = 13\n// \\t = 9\n\nconst splitIntoPotentialTokens = str => {\n\tconst len = str.length;\n\tif (len === 0) return null;\n\tconst results = [];\n\tlet i = 0;\n\tfor (; i < len; ) {\n\t\tconst s = i;\n\t\tblock: {\n\t\t\tlet cc = str.charCodeAt(i);\n\t\t\twhile (cc !== 10 && cc !== 59 && cc !== 123 && cc !== 125) {\n\t\t\t\tif (++i >= len) break block;\n\t\t\t\tcc = str.charCodeAt(i);\n\t\t\t}\n\t\t\twhile (\n\t\t\t\tcc === 59 ||\n\t\t\t\tcc === 32 ||\n\t\t\t\tcc === 123 ||\n\t\t\t\tcc === 125 ||\n\t\t\t\tcc === 13 ||\n\t\t\t\tcc === 9\n\t\t\t) {\n\t\t\t\tif (++i >= len) break block;\n\t\t\t\tcc = str.charCodeAt(i);\n\t\t\t}\n\t\t\tif (cc === 10) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tresults.push(str.slice(s, i));\n\t}\n\treturn results;\n};\nmodule.exports = splitIntoPotentialTokens;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js":
/*!******************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst createMappingsSerializer = __webpack_require__(/*! ./createMappingsSerializer */ \"./node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js\");\nconst streamChunks = __webpack_require__(/*! ./streamChunks */ \"./node_modules/webpack-sources/lib/helpers/streamChunks.js\");\n\nconst streamAndGetSourceAndMap = (\n\tinputSource,\n\toptions,\n\tonChunk,\n\tonSource,\n\tonName\n) => {\n\tlet code = \"\";\n\tlet mappings = \"\";\n\tlet sources = [];\n\tlet sourcesContent = [];\n\tlet names = [];\n\tconst addMapping = createMappingsSerializer(\n\t\tObject.assign({}, options, { columns: true })\n\t);\n\tconst finalSource = !!(options && options.finalSource);\n\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\tinputSource,\n\t\toptions,\n\t\t(\n\t\t\tchunk,\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn,\n\t\t\tsourceIndex,\n\t\t\toriginalLine,\n\t\t\toriginalColumn,\n\t\t\tnameIndex\n\t\t) => {\n\t\t\tif (chunk !== undefined) code += chunk;\n\t\t\tmappings += addMapping(\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t);\n\t\t\treturn onChunk(\n\t\t\t\tfinalSource ? undefined : chunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t);\n\t\t},\n\t\t(sourceIndex, source, sourceContent) => {\n\t\t\twhile (sources.length < sourceIndex) {\n\t\t\t\tsources.push(null);\n\t\t\t}\n\t\t\tsources[sourceIndex] = source;\n\t\t\tif (sourceContent !== undefined) {\n\t\t\t\twhile (sourcesContent.length < sourceIndex) {\n\t\t\t\t\tsourcesContent.push(null);\n\t\t\t\t}\n\t\t\t\tsourcesContent[sourceIndex] = sourceContent;\n\t\t\t}\n\t\t\treturn onSource(sourceIndex, source, sourceContent);\n\t\t},\n\t\t(nameIndex, name) => {\n\t\t\twhile (names.length < nameIndex) {\n\t\t\t\tnames.push(null);\n\t\t\t}\n\t\t\tnames[nameIndex] = name;\n\t\t\treturn onName(nameIndex, name);\n\t\t}\n\t);\n\tconst resultSource = source !== undefined ? source : code;\n\treturn {\n\t\tresult: {\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn,\n\t\t\tsource: finalSource ? resultSource : undefined\n\t\t},\n\t\tsource: resultSource,\n\t\tmap:\n\t\t\tmappings.length > 0\n\t\t\t\t? {\n\t\t\t\t\t\tversion: 3,\n\t\t\t\t\t\tfile: \"x\",\n\t\t\t\t\t\tmappings,\n\t\t\t\t\t\tsources,\n\t\t\t\t\t\tsourcesContent:\n\t\t\t\t\t\t\tsourcesContent.length > 0 ? sourcesContent : undefined,\n\t\t\t\t\t\tnames\n\t\t\t\t  }\n\t\t\t\t: null\n\t};\n};\n\nmodule.exports = streamAndGetSourceAndMap;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/streamChunks.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/streamChunks.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst streamChunksOfRawSource = __webpack_require__(/*! ./streamChunksOfRawSource */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js\");\nconst streamChunksOfSourceMap = __webpack_require__(/*! ./streamChunksOfSourceMap */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js\");\n\nmodule.exports = (source, options, onChunk, onSource, onName) => {\n\tif (typeof source.streamChunks === \"function\") {\n\t\treturn source.streamChunks(options, onChunk, onSource, onName);\n\t} else {\n\t\tconst sourceAndMap = source.sourceAndMap(options);\n\t\tif (sourceAndMap.map) {\n\t\t\treturn streamChunksOfSourceMap(\n\t\t\t\tsourceAndMap.source,\n\t\t\t\tsourceAndMap.map,\n\t\t\t\tonChunk,\n\t\t\t\tonSource,\n\t\t\t\tonName,\n\t\t\t\t!!(options && options.finalSource),\n\t\t\t\t!!(options && options.columns !== false)\n\t\t\t);\n\t\t} else {\n\t\t\treturn streamChunksOfRawSource(\n\t\t\t\tsourceAndMap.source,\n\t\t\t\tonChunk,\n\t\t\t\tonSource,\n\t\t\t\tonName,\n\t\t\t\t!!(options && options.finalSource)\n\t\t\t);\n\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/streamChunks.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst streamChunksOfSourceMap = __webpack_require__(/*! ./streamChunksOfSourceMap */ \"./node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js\");\nconst splitIntoLines = __webpack_require__(/*! ./splitIntoLines */ \"./node_modules/webpack-sources/lib/helpers/splitIntoLines.js\");\n\nconst streamChunksOfCombinedSourceMap = (\n\tsource,\n\tsourceMap,\n\tinnerSourceName,\n\tinnerSource,\n\tinnerSourceMap,\n\tremoveInnerSource,\n\tonChunk,\n\tonSource,\n\tonName,\n\tfinalSource,\n\tcolumns\n) => {\n\tlet sourceMapping = new Map();\n\tlet nameMapping = new Map();\n\tconst sourceIndexMapping = [];\n\tconst nameIndexMapping = [];\n\tconst nameIndexValueMapping = [];\n\tlet innerSourceIndex = -2;\n\tconst innerSourceIndexMapping = [];\n\tconst innerSourceIndexValueMapping = [];\n\tconst innerSourceContents = [];\n\tconst innerSourceContentLines = [];\n\tconst innerNameIndexMapping = [];\n\tconst innerNameIndexValueMapping = [];\n\tconst innerSourceMapLineData = [];\n\tconst findInnerMapping = (line, column) => {\n\t\tif (line > innerSourceMapLineData.length) return -1;\n\t\tconst { mappingsData } = innerSourceMapLineData[line - 1];\n\t\tlet l = 0;\n\t\tlet r = mappingsData.length / 5;\n\t\twhile (l < r) {\n\t\t\tlet m = (l + r) >> 1;\n\t\t\tif (mappingsData[m * 5] <= column) {\n\t\t\t\tl = m + 1;\n\t\t\t} else {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tif (l === 0) return -1;\n\t\treturn l - 1;\n\t};\n\treturn streamChunksOfSourceMap(\n\t\tsource,\n\t\tsourceMap,\n\t\t(\n\t\t\tchunk,\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn,\n\t\t\tsourceIndex,\n\t\t\toriginalLine,\n\t\t\toriginalColumn,\n\t\t\tnameIndex\n\t\t) => {\n\t\t\t// Check if this is a mapping to the inner source\n\t\t\tif (sourceIndex === innerSourceIndex) {\n\t\t\t\t// Check if there is a mapping in the inner source\n\t\t\t\tconst idx = findInnerMapping(originalLine, originalColumn);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tconst { chunks, mappingsData } = innerSourceMapLineData[\n\t\t\t\t\t\toriginalLine - 1\n\t\t\t\t\t];\n\t\t\t\t\tconst mi = idx * 5;\n\t\t\t\t\tconst innerSourceIndex = mappingsData[mi + 1];\n\t\t\t\t\tconst innerOriginalLine = mappingsData[mi + 2];\n\t\t\t\t\tlet innerOriginalColumn = mappingsData[mi + 3];\n\t\t\t\t\tlet innerNameIndex = mappingsData[mi + 4];\n\t\t\t\t\tif (innerSourceIndex >= 0) {\n\t\t\t\t\t\t// Check for an identity mapping\n\t\t\t\t\t\t// where we are allowed to adjust the original column\n\t\t\t\t\t\tconst innerChunk = chunks[idx];\n\t\t\t\t\t\tconst innerGeneratedColumn = mappingsData[mi];\n\t\t\t\t\t\tconst locationInChunk = originalColumn - innerGeneratedColumn;\n\t\t\t\t\t\tif (locationInChunk > 0) {\n\t\t\t\t\t\t\tlet originalSourceLines =\n\t\t\t\t\t\t\t\tinnerSourceIndex < innerSourceContentLines.length\n\t\t\t\t\t\t\t\t\t? innerSourceContentLines[innerSourceIndex]\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (originalSourceLines === undefined) {\n\t\t\t\t\t\t\t\tconst originalSource = innerSourceContents[innerSourceIndex];\n\t\t\t\t\t\t\t\toriginalSourceLines = originalSource\n\t\t\t\t\t\t\t\t\t? splitIntoLines(originalSource)\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex] = originalSourceLines;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (originalSourceLines !== null) {\n\t\t\t\t\t\t\t\tconst originalChunk =\n\t\t\t\t\t\t\t\t\tinnerOriginalLine <= originalSourceLines.length\n\t\t\t\t\t\t\t\t\t\t? originalSourceLines[innerOriginalLine - 1].slice(\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn + locationInChunk\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t: \"\";\n\t\t\t\t\t\t\t\tif (innerChunk.slice(0, locationInChunk) === originalChunk) {\n\t\t\t\t\t\t\t\t\tinnerOriginalColumn += locationInChunk;\n\t\t\t\t\t\t\t\t\tinnerNameIndex = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We have a inner mapping to original source\n\n\t\t\t\t\t\t// emit source when needed and compute global source index\n\t\t\t\t\t\tlet sourceIndex =\n\t\t\t\t\t\t\tinnerSourceIndex < innerSourceIndexMapping.length\n\t\t\t\t\t\t\t\t? innerSourceIndexMapping[innerSourceIndex]\n\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\tif (sourceIndex === -2) {\n\t\t\t\t\t\t\tconst [source, sourceContent] =\n\t\t\t\t\t\t\t\tinnerSourceIndex < innerSourceIndexValueMapping.length\n\t\t\t\t\t\t\t\t\t? innerSourceIndexValueMapping[innerSourceIndex]\n\t\t\t\t\t\t\t\t\t: [null, undefined];\n\t\t\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsourceIndex = globalIndex;\n\t\t\t\t\t\t\tinnerSourceIndexMapping[innerSourceIndex] = sourceIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emit name when needed and compute global name index\n\t\t\t\t\t\tlet finalNameIndex = -1;\n\t\t\t\t\t\tif (innerNameIndex >= 0) {\n\t\t\t\t\t\t\t// when we have a inner name\n\t\t\t\t\t\t\tfinalNameIndex =\n\t\t\t\t\t\t\t\tinnerNameIndex < innerNameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? innerNameIndexMapping[innerNameIndex]\n\t\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\t\t\tconst name =\n\t\t\t\t\t\t\t\t\tinnerNameIndex < innerNameIndexValueMapping.length\n\t\t\t\t\t\t\t\t\t\t? innerNameIndexValueMapping[innerNameIndex]\n\t\t\t\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfinalNameIndex = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinnerNameIndexMapping[innerNameIndex] = finalNameIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (nameIndex >= 0) {\n\t\t\t\t\t\t\t// when we don't have an inner name,\n\t\t\t\t\t\t\t// but we have an outer name\n\t\t\t\t\t\t\t// it can be used when inner original code equals to the name\n\t\t\t\t\t\t\tlet originalSourceLines =\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex];\n\t\t\t\t\t\t\tif (originalSourceLines === undefined) {\n\t\t\t\t\t\t\t\tconst originalSource = innerSourceContents[innerSourceIndex];\n\t\t\t\t\t\t\t\toriginalSourceLines = originalSource\n\t\t\t\t\t\t\t\t\t? splitIntoLines(originalSource)\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex] = originalSourceLines;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (originalSourceLines !== null) {\n\t\t\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\t\t\tconst originalName =\n\t\t\t\t\t\t\t\t\tinnerOriginalLine <= originalSourceLines.length\n\t\t\t\t\t\t\t\t\t\t? originalSourceLines[innerOriginalLine - 1].slice(\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn + name.length\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t: \"\";\n\t\t\t\t\t\t\t\tif (name === originalName) {\n\t\t\t\t\t\t\t\t\tfinalNameIndex =\n\t\t\t\t\t\t\t\t\t\tnameIndex < nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t\t\t? nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tfinalNameIndex = -1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tnameIndexMapping[nameIndex] = finalNameIndex;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tinnerOriginalLine,\n\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\tfinalNameIndex\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We have a mapping to the inner source, but no inner mapping\n\t\t\t\tif (removeInnerSource) {\n\t\t\t\t\tonChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif (sourceIndexMapping[sourceIndex] === -2) {\n\t\t\t\t\t\tlet globalIndex = sourceMapping.get(innerSourceName);\n\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\t\tonSource(globalIndex, innerSourceName, innerSource);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsourceIndexMapping[sourceIndex] = globalIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst finalSourceIndex =\n\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t? -1\n\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\tif (finalSourceIndex < 0) {\n\t\t\t\t// no source, so we make it a generated chunk\n\t\t\t\tonChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t} else {\n\t\t\t\t// Pass through the chunk with mapping\n\t\t\t\tlet finalNameIndex = -1;\n\t\t\t\tif (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {\n\t\t\t\t\tfinalNameIndex = nameIndexMapping[nameIndex];\n\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\tnameIndexMapping[nameIndex] = finalNameIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tfinalSourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tfinalNameIndex\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\t(i, source, sourceContent) => {\n\t\t\tif (source === innerSourceName) {\n\t\t\t\tinnerSourceIndex = i;\n\t\t\t\tif (innerSource !== undefined) sourceContent = innerSource;\n\t\t\t\telse innerSource = sourceContent;\n\t\t\t\tsourceIndexMapping[i] = -2;\n\t\t\t\tstreamChunksOfSourceMap(\n\t\t\t\t\tsourceContent,\n\t\t\t\t\tinnerSourceMap,\n\t\t\t\t\t(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex\n\t\t\t\t\t) => {\n\t\t\t\t\t\twhile (innerSourceMapLineData.length < generatedLine) {\n\t\t\t\t\t\t\tinnerSourceMapLineData.push({\n\t\t\t\t\t\t\t\tmappingsData: [],\n\t\t\t\t\t\t\t\tchunks: []\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst data = innerSourceMapLineData[generatedLine - 1];\n\t\t\t\t\t\tdata.mappingsData.push(\n\t\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tnameIndex\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.chunks.push(chunk);\n\t\t\t\t\t},\n\t\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\t\tinnerSourceContents[i] = sourceContent;\n\t\t\t\t\t\tinnerSourceContentLines[i] = undefined;\n\t\t\t\t\t\tinnerSourceIndexMapping[i] = -2;\n\t\t\t\t\t\tinnerSourceIndexValueMapping[i] = [source, sourceContent];\n\t\t\t\t\t},\n\t\t\t\t\t(i, name) => {\n\t\t\t\t\t\tinnerNameIndexMapping[i] = -2;\n\t\t\t\t\t\tinnerNameIndexValueMapping[i] = name;\n\t\t\t\t\t},\n\t\t\t\t\tfalse,\n\t\t\t\t\tcolumns\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t}\n\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t}\n\t\t},\n\t\t(i, name) => {\n\t\t\tnameIndexMapping[i] = -2;\n\t\t\tnameIndexValueMapping[i] = name;\n\t\t},\n\t\tfinalSource,\n\t\tcolumns\n\t);\n};\n\nmodule.exports = streamChunksOfCombinedSourceMap;\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst getGeneratedSourceInfo = __webpack_require__(/*! ./getGeneratedSourceInfo */ \"./node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js\");\nconst splitIntoLines = __webpack_require__(/*! ./splitIntoLines */ \"./node_modules/webpack-sources/lib/helpers/splitIntoLines.js\");\n\nconst streamChunksOfRawSource = (source, onChunk, onSource, onName) => {\n\tlet line = 1;\n\tconst matches = splitIntoLines(source);\n\tlet match;\n\tfor (match of matches) {\n\t\tonChunk(match, line, 0, -1, -1, -1, -1);\n\t\tline++;\n\t}\n\treturn matches.length === 0 || match.endsWith(\"\\n\")\n\t\t? {\n\t\t\t\tgeneratedLine: matches.length + 1,\n\t\t\t\tgeneratedColumn: 0\n\t\t  }\n\t\t: {\n\t\t\t\tgeneratedLine: matches.length,\n\t\t\t\tgeneratedColumn: match.length\n\t\t  };\n};\n\nmodule.exports = (source, onChunk, onSource, onName, finalSource) => {\n\treturn finalSource\n\t\t? getGeneratedSourceInfo(source)\n\t\t: streamChunksOfRawSource(source, onChunk, onSource, onName);\n};\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\n\nconst getGeneratedSourceInfo = __webpack_require__(/*! ./getGeneratedSourceInfo */ \"./node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js\");\nconst getSource = __webpack_require__(/*! ./getSource */ \"./node_modules/webpack-sources/lib/helpers/getSource.js\");\nconst readMappings = __webpack_require__(/*! ./readMappings */ \"./node_modules/webpack-sources/lib/helpers/readMappings.js\");\nconst splitIntoLines = __webpack_require__(/*! ./splitIntoLines */ \"./node_modules/webpack-sources/lib/helpers/splitIntoLines.js\");\n\nconst streamChunksOfSourceMapFull = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName\n) => {\n\tconst lines = splitIntoLines(source);\n\tif (lines.length === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\tif (names) {\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tonName(i, names[i]);\n\t\t}\n\t}\n\n\tconst lastLine = lines[lines.length - 1];\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\n\n\tlet currentGeneratedLine = 1;\n\tlet currentGeneratedColumn = 0;\n\n\tlet mappingActive = false;\n\tlet activeMappingSourceIndex = -1;\n\tlet activeMappingOriginalLine = -1;\n\tlet activeMappingOriginalColumn = -1;\n\tlet activeMappingNameIndex = -1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\tgeneratedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\tnameIndex\n\t) => {\n\t\tif (mappingActive && currentGeneratedLine <= lines.length) {\n\t\t\tlet chunk;\n\t\t\tconst mappingLine = currentGeneratedLine;\n\t\t\tconst mappingColumn = currentGeneratedColumn;\n\t\t\tconst line = lines[currentGeneratedLine - 1];\n\t\t\tif (generatedLine !== currentGeneratedLine) {\n\t\t\t\tchunk = line.slice(currentGeneratedColumn);\n\t\t\t\tcurrentGeneratedLine++;\n\t\t\t\tcurrentGeneratedColumn = 0;\n\t\t\t} else {\n\t\t\t\tchunk = line.slice(currentGeneratedColumn, generatedColumn);\n\t\t\t\tcurrentGeneratedColumn = generatedColumn;\n\t\t\t}\n\t\t\tif (chunk) {\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tmappingLine,\n\t\t\t\t\tmappingColumn,\n\t\t\t\t\tactiveMappingSourceIndex,\n\t\t\t\t\tactiveMappingOriginalLine,\n\t\t\t\t\tactiveMappingOriginalColumn,\n\t\t\t\t\tactiveMappingNameIndex\n\t\t\t\t);\n\t\t\t}\n\t\t\tmappingActive = false;\n\t\t}\n\t\tif (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\n\t\t\t\t\tcurrentGeneratedColumn\n\t\t\t\t);\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t\tcurrentGeneratedColumn = 0;\n\t\t}\n\t\twhile (generatedLine > currentGeneratedLine) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tonChunk(\n\t\t\t\t\tlines[currentGeneratedLine - 1],\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\t0,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t\tif (generatedColumn > currentGeneratedColumn) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\tgeneratedColumn\n\t\t\t\t);\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedColumn = generatedColumn;\n\t\t}\n\t\tif (\n\t\t\tsourceIndex >= 0 &&\n\t\t\t(generatedLine < finalLine ||\n\t\t\t\t(generatedLine === finalLine && generatedColumn < finalColumn))\n\t\t) {\n\t\t\tmappingActive = true;\n\t\t\tactiveMappingSourceIndex = sourceIndex;\n\t\t\tactiveMappingOriginalLine = originalLine;\n\t\t\tactiveMappingOriginalColumn = originalColumn;\n\t\t\tactiveMappingNameIndex = nameIndex;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\tonMapping(finalLine, finalColumn, -1, -1, -1, -1);\n\treturn {\n\t\tgeneratedLine: finalLine,\n\t\tgeneratedColumn: finalColumn\n\t};\n};\n\nconst streamChunksOfSourceMapLinesFull = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\t_onName\n) => {\n\tconst lines = splitIntoLines(source);\n\tif (lines.length === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\tconst { sources, sourcesContent, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\n\tlet currentGeneratedLine = 1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\t_generatedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\t_nameIndex\n\t) => {\n\t\tif (\n\t\t\tsourceIndex < 0 ||\n\t\t\tgeneratedLine < currentGeneratedLine ||\n\t\t\tgeneratedLine > lines.length\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\twhile (generatedLine > currentGeneratedLine) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tonChunk(\n\t\t\t\t\tlines[currentGeneratedLine - 1],\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\t0,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t\tif (generatedLine <= lines.length) {\n\t\t\tonChunk(\n\t\t\t\tlines[generatedLine - 1],\n\t\t\t\tgeneratedLine,\n\t\t\t\t0,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\t-1\n\t\t\t);\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\tfor (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\n\t\tonChunk(\n\t\t\tlines[currentGeneratedLine - 1],\n\t\t\tcurrentGeneratedLine,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1\n\t\t);\n\t}\n\n\tconst lastLine = lines[lines.length - 1];\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\n\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\n\n\treturn {\n\t\tgeneratedLine: finalLine,\n\t\tgeneratedColumn: finalColumn\n\t};\n};\n\nconst streamChunksOfSourceMapFinal = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName\n) => {\n\tconst result = getGeneratedSourceInfo(source);\n\tconst { generatedLine: finalLine, generatedColumn: finalColumn } = result;\n\n\tif (finalLine === 1 && finalColumn === 0) return result;\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\tif (names) {\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tonName(i, names[i]);\n\t\t}\n\t}\n\n\tlet mappingActiveLine = 0;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\tgeneratedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\tnameIndex\n\t) => {\n\t\tif (\n\t\t\tgeneratedLine >= finalLine &&\n\t\t\t(generatedColumn >= finalColumn || generatedLine > finalLine)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tif (sourceIndex >= 0) {\n\t\t\tonChunk(\n\t\t\t\tundefined,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t);\n\t\t\tmappingActiveLine = generatedLine;\n\t\t} else if (mappingActiveLine === generatedLine) {\n\t\t\tonChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\tmappingActiveLine = 0;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\treturn result;\n};\n\nconst streamChunksOfSourceMapLinesFinal = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\t_onName\n) => {\n\tconst result = getGeneratedSourceInfo(source);\n\tconst { generatedLine, generatedColumn } = result;\n\tif (generatedLine === 1 && generatedColumn === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\n\tconst { sources, sourcesContent, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\n\tconst finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\n\n\tlet currentGeneratedLine = 1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\t_generatedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\t_nameIndex\n\t) => {\n\t\tif (\n\t\t\tsourceIndex >= 0 &&\n\t\t\tcurrentGeneratedLine <= generatedLine &&\n\t\t\tgeneratedLine <= finalLine\n\t\t) {\n\t\t\tonChunk(\n\t\t\t\tundefined,\n\t\t\t\tgeneratedLine,\n\t\t\t\t0,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\t-1\n\t\t\t);\n\t\t\tcurrentGeneratedLine = generatedLine + 1;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\treturn result;\n};\n\nmodule.exports = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName,\n\tfinalSource,\n\tcolumns\n) => {\n\tif (columns) {\n\t\treturn finalSource\n\t\t\t? streamChunksOfSourceMapFinal(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  )\n\t\t\t: streamChunksOfSourceMapFull(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  );\n\t} else {\n\t\treturn finalSource\n\t\t\t? streamChunksOfSourceMapLinesFinal(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  )\n\t\t\t: streamChunksOfSourceMapLinesFull(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  );\n\t}\n};\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js?");

/***/ }),

/***/ "./node_modules/webpack-sources/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/webpack-sources/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nconst defineExport = (name, fn) => {\n\tlet value;\n\tObject.defineProperty(exports, name, {\n\t\tget: () => {\n\t\t\tif (fn !== undefined) {\n\t\t\t\tvalue = fn();\n\t\t\t\tfn = undefined;\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tconfigurable: true\n\t});\n};\n\ndefineExport(\"Source\", () => __webpack_require__(/*! ./Source */ \"./node_modules/webpack-sources/lib/Source.js\"));\n\ndefineExport(\"RawSource\", () => __webpack_require__(/*! ./RawSource */ \"./node_modules/webpack-sources/lib/RawSource.js\"));\ndefineExport(\"OriginalSource\", () => __webpack_require__(/*! ./OriginalSource */ \"./node_modules/webpack-sources/lib/OriginalSource.js\"));\ndefineExport(\"SourceMapSource\", () => __webpack_require__(/*! ./SourceMapSource */ \"./node_modules/webpack-sources/lib/SourceMapSource.js\"));\ndefineExport(\"CachedSource\", () => __webpack_require__(/*! ./CachedSource */ \"./node_modules/webpack-sources/lib/CachedSource.js\"));\ndefineExport(\"ConcatSource\", () => __webpack_require__(/*! ./ConcatSource */ \"./node_modules/webpack-sources/lib/ConcatSource.js\"));\ndefineExport(\"ReplaceSource\", () => __webpack_require__(/*! ./ReplaceSource */ \"./node_modules/webpack-sources/lib/ReplaceSource.js\"));\ndefineExport(\"PrefixSource\", () => __webpack_require__(/*! ./PrefixSource */ \"./node_modules/webpack-sources/lib/PrefixSource.js\"));\ndefineExport(\"SizeOnlySource\", () => __webpack_require__(/*! ./SizeOnlySource */ \"./node_modules/webpack-sources/lib/SizeOnlySource.js\"));\ndefineExport(\"CompatSource\", () => __webpack_require__(/*! ./CompatSource */ \"./node_modules/webpack-sources/lib/CompatSource.js\"));\n\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./node_modules/webpack-sources/lib/index.js?");

/***/ }),

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const stringify = __webpack_require__(/*! fast-json-stable-stringify */ \"./node_modules/fast-json-stable-stringify/index.js\");\r\nconst {\r\n    CompatSource\r\n} = __webpack_require__(/*! webpack-sources */ \"./node_modules/webpack-sources/lib/index.js\");\r\n\r\nwindow.onload = async function () {\r\n\r\n    //Check which page is loaded and only execute that code\r\n    if (document.getElementById('kapsalon-datalist')) {\r\n        await loadKapsalonsHomepage();\r\n    }\r\n    if (document.getElementById('kapsalon-info-section')) {\r\n        await loadKapsalonInfo();\r\n    }\r\n    if (document.getElementById('insert-code-container')) {\r\n        await validateCode();\r\n    }\r\n    if (document.getElementById('rate-form')) {\r\n        await rateKapsalon();\r\n    }\r\n    if (document.getElementById('kapsalon-admin-list')) {\r\n        await loadKapsalonsAdmin();\r\n    }\r\n\r\n    async function loadKapsalonsHomepage() {\r\n        let kapsalonList = [];\r\n\r\n        //fetch all kapsalons\r\n        await fetch('https://web2-kapsamazing-driesv.herokuapp.com/kapsalons')\r\n            .then(response => {\r\n                return response.json();\r\n            })\r\n            .then(data => {\r\n                kapsalonList = data;\r\n\r\n                //sort and render the kapsalons for the very first time on rating (default)\r\n                sortKapsalons(kapsalonList, \"rating\");\r\n                renderKapsalonList(kapsalonList);\r\n            })\r\n\r\n        //if filters or searchfield changes, update the list\r\n        if (document.getElementById('search-location-form')) {\r\n            document.getElementById('search-location-form').addEventListener('submit', e => {\r\n                e.preventDefault();\r\n                if (document.getElementById('search-location-input').value != \"\") {\r\n                    updateLocation(kapsalonList);\r\n                }\r\n            })\r\n        }\r\n\r\n        if (document.getElementById('filter-type-form')) {\r\n            document.getElementById('filter-type-form').addEventListener('change', e => {\r\n                e.preventDefault();\r\n                if (document.getElementById('search-location-input').value != \"\") {\r\n                    updateLocation(kapsalonList);\r\n                } else {\r\n                    updateList(kapsalonList);\r\n                }\r\n            })\r\n        }\r\n\r\n        if (document.getElementById('filter-options-form')) {\r\n            document.getElementById('filter-options-form').addEventListener('change', e => {\r\n                e.preventDefault();\r\n                if (document.getElementById('search-location-input').value != \"\") {\r\n                    updateLocation(kapsalonList);\r\n                } else {\r\n                    updateList(kapsalonList);\r\n                }\r\n            })\r\n        }\r\n\r\n        if (document.getElementById('order-by-form')) {\r\n            document.getElementById('order-by-form').addEventListener('change', e => {\r\n                e.preventDefault();\r\n                if (document.getElementById('search-location-input').value != \"\") {\r\n                    updateLocation(kapsalonList);\r\n                } else {\r\n                    updateList(kapsalonList);\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    async function loadKapsalonInfo() {\r\n        let kapsalonInfo;\r\n\r\n        //fetch kapsalon that has been selected in the list\r\n        await fetch(`https://web2-kapsamazing-driesv.herokuapp.com/kapsalon/${localStorage.kapsalonId}`)\r\n            .then(response => {\r\n                return response.json();\r\n            })\r\n            .then(data => {\r\n                kapsalonInfo = data;\r\n            })\r\n\r\n        //load content of that specific kapsalon\r\n        if (document.getElementById('kapsalon-info-section')) {\r\n            document.getElementById('kapsalon-info-section').innerHTML = `\r\n                <figure class=\"kapsalon-info-figure\">\r\n                <img class=\"kapsalon-info-img\" src=\"${kapsalonInfo.image}\" alt=\"kapsalon from ${kapsalonInfo.restaurant}\">\r\n            </figure>\r\n            <div id=\"kapsalon-info-container\">\r\n                <div id=\"kapsalon-info-header\">\r\n                    <div id=\"kapsalon-info-header-text\">\r\n                        <h3 id=\"kapsalon-info-header-title\">${kapsalonInfo.name}</h3>\r\n                        <div id=\"kapsalon-info-header-restaurant\">\r\n                            <div id=\"info-header-restaurant-name\">${kapsalonInfo.restaurant}</div>\r\n                            <div id=\"info-header-restaurant-distance\">${kapsalonInfo.city}</div>\r\n                        </div>\r\n                    </div>\r\n                    <div id=\"kapsalon-info-header-rating\">\r\n                        <div class=\"kapsalon-article-rating-number\">${calculateGeneralScore(kapsalonInfo.ratings)}\r\n                    </div>\r\n                </div>\r\n                <div id=\"kapsalon-info-scores\">\r\n                    <h4 id=\"kapsalon-info-scores-title\">Scores</h4>\r\n                    <div id=\"info-scores-content\">\r\n                        <div id=\"info-scores-toppic\">\r\n                            <div>Fries</div>\r\n                            <div>Meat</div>\r\n                            <div>Toppings</div>\r\n                        </div>\r\n                        <div id=\"info-scores-number\">\r\n                            <div>${calculateIngredientScore(\"fries\", kapsalonInfo.ratings)}</div>\r\n                            <div>${calculateIngredientScore(\"meat\", kapsalonInfo.ratings)}</div>\r\n                            <div>${calculateIngredientScore(\"toppings\", kapsalonInfo.ratings)}</div>\r\n                        </div>\r\n                        <div id=\"info-scores-stars\">\r\n                            <div>${calculateStars(parseFloat(calculateIngredientScore(\"fries\", kapsalonInfo.ratings)))}</div>\r\n                            <div>${calculateStars(parseFloat(calculateIngredientScore(\"meat\", kapsalonInfo.ratings)))}</div>\r\n                            <div>${calculateStars(parseFloat(calculateIngredientScore(\"toppings\", kapsalonInfo.ratings)))}</div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div id=\"kapsalon-info-order\">\r\n                    <a href=\"${kapsalonInfo.link}\" target=\"_blank\">Order</a>\r\n                    <div>€${kapsalonInfo.price}</div>\r\n                </div>\r\n            </div>\r\n                `;\r\n\r\n            //adjust the rest of the page to the rest of the info\r\n            document.getElementById('other-meals-title').innerHTML = `\r\n                Other meals from ${kapsalonInfo.restaurant}\r\n                `;\r\n\r\n            //fetch all other kapsalons of that restaurant\r\n            fetch('https://web2-kapsamazing-driesv.herokuapp.com/kapsalons')\r\n                .then(response => {\r\n                    return response.json();\r\n                })\r\n                .then(data => {\r\n                    kapsalonList = data;\r\n                    filterKapsalonsRestaurant(kapsalonList, kapsalonInfo.restaurant, kapsalonInfo.city, kapsalonInfo._id);\r\n                    renderKapsalonList(kapsalonList);\r\n                })\r\n\r\n            //show location of the restaurant of this kapsalon\r\n            showLocation(kapsalonInfo);\r\n        }\r\n    }\r\n\r\n    async function validateCode() {\r\n        if (document.getElementById('insert-code-form')) {\r\n\r\n            let kapid;\r\n            let kapsalonId;\r\n\r\n            document.getElementById('insert-code-form').addEventListener('submit', e => {\r\n                e.preventDefault('submit');\r\n                kapid = document.getElementById('insert-code-input').value;\r\n\r\n                //fetch kapsalon with submitted kapid (6 digits) and save the _id in localstorage\r\n                fetch(`https://web2-kapsamazing-driesv.herokuapp.com/kapsalon/?id=${kapid}`)\r\n                    .then(response => {\r\n                        return response.json();\r\n                    })\r\n                    .then(data => {\r\n                        kapsalonId = data._id;\r\n\r\n                        localStorage.setItem(\"kapsalonId\", kapsalonId);\r\n\r\n                        window.location.href = './rate.html'\r\n                    })\r\n                    .catch(error => {\r\n                        alert(\"This is not a valid code, please try another combination\");\r\n                    })\r\n            })\r\n        }\r\n    }\r\n\r\n    async function rateKapsalon() {\r\n        let kapsalonInfo;\r\n\r\n        //fetch the kapsalon saved in localstore\r\n        await fetch(`https://web2-kapsamazing-driesv.herokuapp.com/kapsalon/${localStorage.kapsalonId}`)\r\n            .then(response => {\r\n                return response.json();\r\n            })\r\n            .then(data => {\r\n                kapsalonInfo = data;\r\n            })\r\n\r\n        if (document.getElementById('rate-form')) {\r\n\r\n            //adjust page to this specific kapsalon\r\n            document.getElementById(\"rate-title\").innerHTML = `Rate \"${kapsalonInfo.name}\" from \"${kapsalonInfo.restaurant}\"`;\r\n            document.getElementById(\"rate-kapsalon-figure\").innerHTML = `<img class=\"kapsalon-info-img\" src=\"${kapsalonInfo.image}\" alt=\"Kapsalon from ${kapsalonInfo.restaurant}\">`\r\n\r\n            //save rating\r\n            document.getElementById('rate-form').addEventListener('submit', e => {\r\n                e.preventDefault();\r\n\r\n                //get values for each ingredient\r\n                let ratingFries = document.getElementById('range-fries').value;\r\n                let ratingMeat = document.getElementById('range-meat').value;\r\n                let ratingToppings = document.getElementById('range-toppings').value;\r\n\r\n                //correct the values to a point out of 5\r\n                ratingFries = parseInt(ratingFries) / 2;\r\n                ratingMeat = parseInt(ratingMeat) / 2;\r\n                ratingToppings = parseInt(ratingToppings) / 2;\r\n\r\n                let allRatings = [];\r\n\r\n                //save already existing ratings\r\n                kapsalonInfo.ratings.forEach(e => {\r\n                    allRatings.push(e);\r\n                })\r\n\r\n                //create new rating format\r\n                let newRating = {\r\n                    \"fries\": ratingFries,\r\n                    \"meat\": ratingMeat,\r\n                    \"toppings\": ratingToppings\r\n                }\r\n\r\n                //add new rating to all other ratings\r\n                allRatings.push(newRating);\r\n\r\n                //calculate the latest overall rating, so it shows up correctly in the list\r\n                let newGeneralRating = calculateGeneralScoreNumber(kapsalonInfo.ratings);\r\n\r\n                //if this new rating is the first ever rating, than calculate the total score\r\n                if (newGeneralRating == \"no score yet\") {\r\n                    newGeneralRating = Math.round(((ratingFries + ratingMeat + ratingToppings) / 3 + Number.EPSILON) * 10) / 10;\r\n                }\r\n\r\n                //create object to adjust in the database\r\n                const kap = {\r\n                    \"ratings\": allRatings,\r\n                    \"latestGeneralRating\": newGeneralRating\r\n                }\r\n\r\n                //save the new rating\r\n                fetch(`https://web2-kapsamazing-driesv.herokuapp.com/rateKapsalon/${localStorage.kapsalonId}`, {\r\n                        method: \"PUT\",\r\n                        headers: {\r\n                            \"Content-Type\": \"application/json\"\r\n                        },\r\n                        body: JSON.stringify(kap)\r\n                    })\r\n                    .then(res => {\r\n                        res.json()\r\n                    })\r\n                    .then(data => {\r\n                        if (data == undefined) {\r\n                            alert(\"Thank you for your rating! Kapsalon-lovers will thank you!\");\r\n                            window.location.href = './index.html';\r\n                        }\r\n                    });\r\n\r\n            })\r\n\r\n        }\r\n\r\n        //if sliders change, calculate the general score of the rating\r\n        if (document.getElementById('rate-form')) {\r\n            document.getElementById('rate-form').addEventListener('change', e => {\r\n                document.getElementById('rate-overall-score').innerHTML = updateGeneralRating();\r\n            });\r\n        }\r\n    }\r\n\r\n    async function loadKapsalonsAdmin() {\r\n        let kapsalonList = [];\r\n\r\n        //fetch all kapsalons\r\n        await fetch('https://web2-kapsamazing-driesv.herokuapp.com/kapsalons')\r\n            .then(response => {\r\n                return response.json();\r\n            })\r\n            .then(data => {\r\n                kapsalonList = data;\r\n                renderKapsalonsAdmin(kapsalonList);\r\n            })\r\n\r\n        if (document.getElementById('add-kapsalon-form')) {\r\n            let addForm = document.getElementById('add-kapsalon-form');\r\n            addForm.addEventListener('submit', e => {\r\n                e.preventDefault();\r\n\r\n                //if new kapsalon is submitted, get all values\r\n                let newKapid = document.getElementById('kapsalon-kapid').value;\r\n                let newName = document.getElementById('kapsalon-name').value;\r\n                let newRestaurant = document.getElementById('kapsalon-restaurant').value;\r\n                let newCity = document.getElementById('kapsalon-city').value;\r\n                let newPrice = document.getElementById('kapsalon-price').value;\r\n                let newType = document.getElementById('kapsalon-type').value;\r\n                let newDelivered = document.getElementById('kapsalon-delivered').value;\r\n                let newImage = document.getElementById('kapsalon-image').value;\r\n                let newLink = document.getElementById('kapsalon-link').value;\r\n                let newLatitude = document.getElementById('kapsalon-latitude').value;\r\n                let newLongitude = document.getElementById('kapsalon-longitude').value;\r\n\r\n                let deliveredOptions = [];\r\n\r\n                //create correct values for delivered options, so it works with the database\r\n                if (newDelivered == \"pickup-and-delivery\") {\r\n                    deliveredOptions.push(\"pickup\");\r\n                    deliveredOptions.push(\"delivery\")\r\n                } else if (newDelivered == \"pickup\") {\r\n                    deliveredOptions.push(\"pickup\");\r\n                } else if (newDelivered == \"delivery\") {\r\n                    deliveredOptions.push(\"delivery\");\r\n                }\r\n\r\n                //create correct object to save in the database\r\n                const kap = {\r\n                    kapid: newKapid,\r\n                    name: newName,\r\n                    city: newCity,\r\n                    restaurant: newRestaurant,\r\n                    type: newType,\r\n                    delivered: deliveredOptions,\r\n                    price: parseFloat(newPrice),\r\n                    ratings: [],\r\n                    latitude: parseFloat(newLatitude),\r\n                    longitude: parseFloat(newLongitude),\r\n                    latestGeneralRating: 3,\r\n                    image: newImage,\r\n                    link: newLink\r\n                }\r\n\r\n                //fetch the new kapsalon to the database\r\n                fetch(\"https://web2-kapsamazing-driesv.herokuapp.com/saveKapsalon\", {\r\n                        method: \"POST\",\r\n                        headers: {\r\n                            \"Content-Type\": \"application/json\",\r\n                        },\r\n                        body: JSON.stringify(kap)\r\n                    })\r\n                    .then(res => {\r\n                        res.json()\r\n                    })\r\n                    .then(data => {\r\n                        alert(\"Kapsalon succesful added!\");\r\n                        location.reload();\r\n                    })\r\n                    .catch(error => {\r\n                        alert(\"Something went wrong, code may exist already\", error);\r\n                    });\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n//function to render all kapsalons in a format like on the homepage\r\nfunction renderKapsalonList(kapsalonList) {\r\n    let kapsalonListHomepageHTML = \"\";\r\n    kapsalonList.forEach(e => {\r\n        kapsalonListHomepageHTML += `\r\n            <a class=\"kapsalon-article-a\" href=\"./kapsalon-info.html\">\r\n            <article class=\"datalist-kapsalon-article\" id=\"${e._id}\">\r\n                <figure class=\"kapsalon-article-figure\">\r\n                    <img class=\"kapsalon-article-img\" src=\"${e.image}\" alt=\"kapsalon from ${e.restaurant}\">\r\n                </figure>\r\n                <div class=\"kapsalon-article-info\">\r\n                    <h4 class=\"kapsalon-article-title\">${e.name}</h4>\r\n                    <div class=\"kapsalon-article-restaurant\">\r\n                        <span class=\"icon-location edit-location-icon\"></span>\r\n                        <div class=\"kapsalon-article-restaurant-name\">${e.restaurant}</div>\r\n                        <div class=\"kapsalon-article-restaurant-distance\">${e.city}</div>\r\n                    </div>\r\n                </div>\r\n                <div class=\"kapsalon-article-moreinfo\">\r\n                    <div class=\"kapsalon-article-rating\">\r\n                        <div class=\"kapsalon-article-rating-number\">${calculateGeneralScore(e.ratings)}\r\n                    </div>\r\n                    <div class=\"kapsalon-article-price\">€${e.price}</div>\r\n                </div>\r\n            </article>\r\n        </a>\r\n            `\r\n    });\r\n\r\n    //check if there are kapsalons available, otherwise create notification\r\n    if (document.getElementById('kapsalon-datalist')) {\r\n        if (kapsalonListHomepageHTML == \"\") {\r\n            kapsalonListHomepageHTML = `<div class=\"no-kapsalons-message\">No kapsalons found with your filters.</div>`;\r\n        }\r\n\r\n        //when clicked on a kapsalon, get _id and save it in localstorage\r\n        document.getElementById('kapsalon-datalist').innerHTML = kapsalonListHomepageHTML;\r\n        document.getElementById('kapsalon-datalist').addEventListener('click', e => {\r\n\r\n            const kapsalonId = e.target.closest('.datalist-kapsalon-article').id;\r\n\r\n            if (kapsalonId) {\r\n                localStorage.setItem(\"kapsalonId\", kapsalonId);\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n//function to render all kapsalons in a format like on the adminpage\r\nfunction renderKapsalonsAdmin(kapsalonList) {\r\n    let kapsalonListAdminHTML = \"\";\r\n    kapsalonList.forEach(e => {\r\n        kapsalonListAdminHTML += `\r\n        <article class=\"datalist-kapsalon-article\" id=\"${e._id}\">\r\n        <figure class=\"kapsalon-article-figure\">\r\n            <img class=\"kapsalon-article-img\" src=\"${e.image}\" alt=\"kapsalon from ${e.restaurant}\">\r\n        </figure>\r\n        <div class=\"kapsalon-article-info-admin\">\r\n            <h4 class=\"kapsalon-article-title\">${e.name}</h4>\r\n            <div class=\"kapsalon-article-restaurant\">\r\n                <span class=\"icon-location edit-location-icon\"></span>\r\n                <div class=\"kapsalon-article-restaurant-name\">${e.restaurant}</div>\r\n                <div class=\"kapsalon-article-restaurant-price\">€${e.price}</div>\r\n                <div class=\"kapsalon-article-restaurant-id\">code: ${e.kapid}</div>\r\n            </div>\r\n        </div>\r\n        <div class=\"kapsalon-article-edit\">\r\n            <span class=\"icon-bin\"></span>\r\n            <span class=\"icon-pencil\"></span>\r\n        </div>\r\n    </article>\r\n            `\r\n    });\r\n\r\n    //check if there are kapsalons available, otherwise create notification\r\n    if (document.getElementById('kapsalon-admin-list')) {\r\n        if (kapsalonListAdminHTML == \"\") {\r\n            kapsalonListHomepageHTML = `<div class=\"no-kapsalons-message\">No kapsalons added yet.</div>`\r\n        }\r\n\r\n        //when clicked on a kapsalon trash icon, get _id and execute delete kapsalon function\r\n        document.getElementById('kapsalon-admin-list').innerHTML = kapsalonListAdminHTML;\r\n        document.getElementById('kapsalon-admin-list').addEventListener('click', e => {\r\n\r\n            const kapsalonId = e.target.closest('.datalist-kapsalon-article').id;\r\n\r\n            if (kapsalonId) {\r\n                if (e.target.className == \"icon-bin\") {\r\n                    deleteKapsalon(kapsalonId);\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n//function to delete kapsalon\r\nfunction deleteKapsalon(kapsalonId) {\r\n\r\n    //fetch the deleted kapsalon\r\n    fetch(`https://web2-kapsamazing-driesv.herokuapp.com/deleteKapsalon/${kapsalonId}`, {\r\n            method: \"DELETE\",\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            }\r\n        })\r\n        .then(response => {\r\n            return response.json()\r\n        })\r\n        .then(data => {\r\n            if (data) {\r\n                location.reload();\r\n            }\r\n        })\r\n}\r\n\r\n//function to filter all kapsalons on location or restaurant\r\nfunction updateLocation(kapsalonList) {\r\n    let newList = [];\r\n\r\n    //get input value\r\n    let city = document.getElementById('search-location-input').value;\r\n\r\n    //make first character of inputed value capital\r\n    city = city.charAt(0).toUpperCase() + city.slice(1);\r\n    //Source: https://flexiple.com/javascript-capitalize-first-letter/\r\n\r\n    //check all kapsalons if value is used\r\n    kapsalonList.forEach(e => {\r\n        if (e.city.includes(city) || e.restaurant.includes(`${city}`)) {\r\n            newList.push(e);\r\n        }\r\n    })\r\n\r\n    updateList(newList);\r\n}\r\n\r\n//function to update all kapsalon list based on filter by type and delivered options\r\nfunction updateList(kapsalonList) {\r\n    let newList = [];\r\n\r\n    //Source: https://stackoverflow.com/questions/48315428/how-to-make-a-filter-in-javascript-which-filters-div-by-checkboxes/48316156\r\n    let kapsalons = document.querySelectorAll(\"#filter-type-form input[type='checkbox']\");\r\n    let options = document.querySelectorAll(\"#filter-options-form input[type='checkbox']\");\r\n    let orderBy = document.getElementById('order-by-input').value;\r\n\r\n    //check each checkbox if checked, than push all relevant kapsalons to new list\r\n    kapsalons.forEach(e => {\r\n        if (e.checked == true) {\r\n            kapsalonList.forEach(el => {\r\n                if (e.name == el.type) {\r\n                    newList.push(el);\r\n                }\r\n            })\r\n        }\r\n    })\r\n\r\n    let finalList = []; //i know, these lists are not named well\r\n\r\n    //check for each delivered option, if checkboxes are checked and push relevant kapsalons to final list\r\n    if (options[0].checked == true && options[1].checked == true) {\r\n        newList.forEach(e => {\r\n            if (e.delivered.includes(\"pickup\") || e.delivered.includes(\"delivery\")) {\r\n                finalList.push(e);\r\n            }\r\n        })\r\n    } else if (options[0].checked == true) {\r\n        newList.forEach(e => {\r\n            if (e.delivered.includes(\"pickup\")) {\r\n                finalList.push(e);\r\n            }\r\n        })\r\n    } else if (options[1].checked == true) {\r\n        newList.forEach(e => {\r\n            if (e.delivered.includes(\"delivery\")) {\r\n                finalList.push(e);\r\n            }\r\n        })\r\n    } else {\r\n        //if nothing is selected, all kapsalons will be shown\r\n        finalList = newList;\r\n    }\r\n\r\n    //check other filter possibilities\r\n    sortKapsalons(finalList, orderBy)\r\n    renderKapsalonList(finalList);\r\n}\r\n\r\n//function to sort kapsalons by price or rating\r\nfunction sortKapsalons(kapsalonList, orderBy) {\r\n\r\n    if (orderBy == \"rating\") {\r\n        kapsalonList.sort((a, b) => {\r\n            return b[\"latestGeneralRating\"] - a[\"latestGeneralRating\"];\r\n        })\r\n    } else {\r\n        kapsalonList.sort((a, b) => {\r\n            return a[\"price\"] - b[\"price\"];\r\n        })\r\n    }\r\n}\r\n\r\n//function to filter all other kapsalons of the restaurant of the selected kapsalon\r\nfunction filterKapsalonsRestaurant(kapsalonList, restaurant, city, currentKapsalon) {\r\n    let newList = [];\r\n    kapsalonList.forEach(e => {\r\n        //check both restaurant and city to prevent same named restaurants\r\n        if (e.restaurant == restaurant && e.city == city && e._id != currentKapsalon) {\r\n            newList.push(e);\r\n        }\r\n    })\r\n    renderCommonRestaurant(newList);\r\n}\r\n\r\n//function to render kapsalons of the same restaurant\r\nfunction renderCommonRestaurant(kapsalonList) {\r\n    let kapsalonListCommonHTML = \"\";\r\n    kapsalonList.forEach(e => {\r\n        kapsalonListCommonHTML += `\r\n        <a class=\"kapsalon-article-a\" href=\"#\">\r\n            <article class=\"datalist-kapsalon-article\" id=\"${e._id}\">\r\n                <figure class=\"kapsalon-article-figure\">\r\n                    <img class=\"kapsalon-article-img\" src=\"${e.image}\" alt=\"kapsalon from ${e.restaurant}\">\r\n                </figure>\r\n                <div class=\"kapsalon-article-info\">\r\n                    <h4 class=\"kapsalon-article-title\">${e.name}</h4>\r\n                    <div class=\"kapsalon-article-restaurant\">\r\n                        <span class=\"icon-location edit-location-icon\"></span>\r\n                        <div class=\"kapsalon-article-restaurant-name\">${e.restaurant}</div>\r\n                        <div class=\"kapsalon-article-restaurant-distance\">${e.city}</div>\r\n                    </div>\r\n                </div>\r\n                <div class=\"kapsalon-article-moreinfo\">\r\n                    <div class=\"kapsalon-article-rating\">\r\n                        <div class=\"kapsalon-article-rating-number\">${calculateGeneralScore(e.ratings)}\r\n                    </div>\r\n                    <div class=\"kapsalon-article-price\">€${e.price}</div>\r\n                </div>\r\n            </article>\r\n        </a>\r\n            `\r\n    });\r\n\r\n    //check if there are kapsalons available, otherwise create notification\r\n    if (document.getElementById('other-meals-datalist')) {\r\n        if (kapsalonListCommonHTML == \"\") {\r\n            kapsalonListHomepageHTML = `<div class=\"no-kapsalons-message\">No other kapsalons found.</div>`\r\n        }\r\n\r\n        //when clicked on a kapsalon, get _id and save it in localstorage\r\n        document.getElementById('other-meals-datalist').innerHTML = kapsalonListCommonHTML;\r\n        document.getElementById('other-meals-datalist').addEventListener('click', e => {\r\n\r\n            const kapsalonId = e.target.closest('.datalist-kapsalon-article').id;\r\n\r\n            if (kapsalonId) {\r\n                localStorage.setItem(\"kapsalonId\", kapsalonId);\r\n                location.reload();\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n//function to calculate the general overall score of all existing ratings\r\nfunction calculateGeneralScore(ratings) {\r\n    if (ratings.length > 0) {\r\n\r\n        let generalScore = 0;\r\n        let numberRatings = 0;\r\n\r\n        ratings.forEach(e => {\r\n            generalScore += e.fries + e.meat + e.toppings;\r\n            numberRatings += 1;\r\n        })\r\n\r\n        generalScore = Math.round((generalScore / (numberRatings * 3) + Number.EPSILON) * 10) / 10;\r\n\r\n        return `${generalScore}/5 <div class=\"lightbrown\">(${numberRatings})</div></div>${calculateStars(generalScore)}`;\r\n        //Source: https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary\r\n\r\n    } else {\r\n\r\n        let stars = \"\";\r\n        let starEmpty = `<span class=\"icon-star-empty edit-star-icon\"></span>`;\r\n\r\n        for (let i = 0; i < 5; i++) {\r\n            stars += `${starEmpty}`;\r\n        }\r\n        return `no score yet </div>${stars}`;\r\n    }\r\n}\r\n\r\n//function to calculate how many stars must be shown\r\nfunction calculateStars(score) {\r\n    let stars = \"\";\r\n    let starEmpty = `<span class=\"icon-star-empty edit-star-icon\"></span>`;\r\n    let starFull = `<span class=\"icon-star-full edit-star-icon\"></span>`;\r\n\r\n    if (score > 4.5) {\r\n        for (let i = 0; i < 5; i++) {\r\n            stars += `${starFull}`;\r\n        }\r\n    } else if (score > 3.5) {\r\n        for (let i = 0; i < 4; i++) {\r\n            stars += `${starFull}`;\r\n        }\r\n        stars += `${starEmpty}`;\r\n    } else if (score > 2.5) {\r\n        for (let i = 0; i < 3; i++) {\r\n            stars += `${starFull}`;\r\n        }\r\n        for (let i = 0; i < 2; i++) {\r\n            stars += `${starEmpty}`;\r\n        }\r\n    } else if (score > 1.5) {\r\n        for (let i = 0; i < 2; i++) {\r\n            stars += `${starFull}`;\r\n        }\r\n        for (let i = 0; i < 3; i++) {\r\n            stars += `${starEmpty}`;\r\n        }\r\n    } else if (score > 0.5) {\r\n        for (let i = 0; i < 1; i++) {\r\n            stars += `${starFull}`;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            stars += `${starEmpty}`;\r\n        }\r\n    } else {\r\n        for (let i = 0; i < 5; i++) {\r\n            stars += `${starEmpty}`;\r\n        }\r\n    }\r\n    return stars;\r\n}\r\n\r\n//function to calculate the latest general overall rating\r\nfunction calculateGeneralScoreNumber(ratings) {\r\n    if (ratings.length > 0) {\r\n\r\n        let generalScore = 0;\r\n        let numberRatings = 0;\r\n\r\n        ratings.forEach(e => {\r\n            generalScore += e.fries + e.meat + e.toppings;\r\n            numberRatings += 1;\r\n        })\r\n\r\n        generalScore = Math.round((generalScore / (numberRatings * 3) + Number.EPSILON) * 10) / 10;\r\n\r\n        return generalScore;\r\n        //Source: https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary\r\n\r\n    } else {\r\n        return `no score yet`;\r\n    }\r\n}\r\n\r\n//function to calculate the average score of each ingredient\r\nfunction calculateIngredientScore(ingredient, ratings) {\r\n    if (ratings.length > 0) {\r\n        let ingredientScore = 0;\r\n        let numberRatings = 0;\r\n        ratings.forEach(e => {\r\n            if (ingredient == \"fries\") {\r\n                ingredientScore += e.fries;\r\n            } else if (ingredient == \"meat\") {\r\n                ingredientScore += e.meat;\r\n            } else {\r\n                ingredientScore += e.toppings;\r\n            }\r\n            numberRatings += 1;\r\n        })\r\n\r\n        return `${Math.round((ingredientScore / numberRatings + Number.EPSILON) * 10) / 10}/5`\r\n    } else {\r\n        return `?/5`\r\n    }\r\n}\r\n\r\n//function to update general rating of ratepage when changing the sliders\r\nfunction updateGeneralRating() {\r\n    let ratingFries = document.getElementById('range-fries').value;\r\n    let ratingMeat = document.getElementById('range-meat').value;\r\n    let ratingToppings = document.getElementById('range-toppings').value;\r\n\r\n    let generalRating = 0;\r\n    generalRating = parseInt(ratingFries) + parseInt(ratingMeat) + parseInt(ratingToppings);\r\n\r\n    return `${Math.round((generalRating / 6 + Number.EPSILON) * 10) / 10}/5`;\r\n}\r\n\r\n//function to correctly show the location of the restaurant and add a label\r\nfunction showLocation(kapsalonInfo) {\r\n    //Source: https://docs.mapbox.com/help/tutorials/custom-markers-gl-js/\r\n    mapboxgl.accessToken =\r\n        'pk.eyJ1IjoiZHJpZXN2YW5taWVybG8iLCJhIjoiY2t4YWRyMHprMHRsdjMwbzFuYnhyYTJoYiJ9.g5b9eLexlxz1LMfwgJnTMA';\r\n\r\n    const geojson = {\r\n        'type': 'FeatureCollection',\r\n        'features': [{\r\n            'type': 'Feature',\r\n            'geometry': {\r\n                'type': 'Point',\r\n                'coordinates': [kapsalonInfo.longitude, kapsalonInfo.latitude]\r\n            },\r\n            'properties': {\r\n                'title': `${kapsalonInfo.restaurant}`,\r\n                'description': `${kapsalonInfo.city}`\r\n            }\r\n        }]\r\n    };\r\n\r\n    const map = new mapboxgl.Map({\r\n        container: 'map',\r\n        style: 'mapbox://styles/driesvanmierlo/ckxad43w3bkwr14pczh7w3g0x',\r\n        center: [kapsalonInfo.longitude, kapsalonInfo.latitude],\r\n        zoom: 16\r\n    });\r\n\r\n    for (const feature of geojson.features) {\r\n        const el = document.createElement('div');\r\n        el.className = 'marker';\r\n\r\n        new mapboxgl.Marker(el)\r\n            .setLngLat(feature.geometry.coordinates)\r\n            .setPopup(\r\n                new mapboxgl.Popup({\r\n                    offset: 25\r\n                })\r\n                .setHTML(\r\n                    `<h3>${feature.properties.title}</h3><p>${feature.properties.description}</p>`\r\n                )\r\n            )\r\n            .addTo(map);\r\n    }\r\n}\n\n//# sourceURL=webpack://web2-frontend-driesvanmierlo/./src/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/script.js");
/******/ 	
/******/ })()
;